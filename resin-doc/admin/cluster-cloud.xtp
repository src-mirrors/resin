<document>
<header>
  <product>resin</product>
  <title>Cluster: Elastic Server (Cloud) configuration</title>
  <version>Resin 4.0</version>

  <description>

    <p>
      Configuration and deployment of an elastic-server Resin cluster.
    </p>

  </description>
</header>
<body>

<localtoc/>

<s1 title="Overview">

<p>Resin's cloud support is an extension of its clustering. It is the
third generation of Resin clustering, designed for elastic clusters:
adding and removing servers from a live cluster.</p>

<p>A triple-redundant hub-and-spoke network is the heart of
a Resin cluster. The three servers that form the hub are called the
'triad' and are responsible for reliability and for load-balancing
clustered services like caching. All other servers can be added or
removed without affecting the shared data.</p>

<p>Services like clustered deployment, caching, JMS, and
load-balancing recognize the new server and automatically add it to
the service. When you delete a server, the services will adapt to the
smaller network.</p>

<figure src="cloud-hub.png" alt="Resin's hub-and-spoke cloud model"/>

</s1>

<s1 title="Basic Configuration">

<p>The basic cloud configuration is like a normal Resin configuration:
define the three triad servers in your resin.xml, and copy the resin.xml
across all servers. You will attach new servers to the cluster when
you start it on the command-line. You can still define more servers in
the resin.xml, or fewer if you have a small deployment; it's just the
basic resin.xml example that uses three servers.</p>

<example title="Example: basic resin.xml for a 3-server hub">
&lt;resin xmlns="http://caucho.com/ns/resin">
...
&lt;cluster id="my-cluster">

  <b>&lt;server id="a" address="192.168.1.10" port="6800"/>
  &lt;server id="b" address="192.168.1.11" port="6800"/>
  &lt;server id="c" address="192.168.1.12" port="6800"/></b><br/>

  ...
&lt;/cluster>
...
&lt;/resin>
</example>

<p>The first three &lt;server> tags in a cluster always form the
triad. If you have one or two servers, they will still form the
hub. One server acts like a Resin standalone; two servers back each
other up. More than three &lt;server> tags form static servers acting
as spoke servers in the hub-and-spoke model. The static servers are
identical to any elastic servers, but are predefined in the
resin.xml</p>

<s2 title="command-line: adding an elastic server">

<p>Before starting a server, your new machine needs the following to
be installed:</p>

<ol>
<li>The Java JDK</li>
<li>Resin and your licenses</li>
<li>Your resin.xml which defines the three triad servers</li>
</ol>

<p>Since these three items are the same for each new server, you can
make a virtual machine image with these already saved, use the VM
image for the new machine and start it.</p>

<p>To start a new server, you'll add a '--join-cluster' option with
the name of the cluster you want to join.</p>

<example title="Example: command-line starting an elastic server">
unix> bin/resin.sh --join-cluster my-cluster start
</example>

<p>If you don't have a &lt;resin-system-auth-key> in the resin.xml,
and you do have admin users defined in the AdminAuthenticator, you
will also need to pass a -user and -password arguments.</p>

<p>The new server will join the cluster by contacting the triad. It
will then download any deployed applications or data, and then start
serving pages.</p>

<p>The triad will inform cluster services about the load balancer,
services like caching, admin, JMS, and load-balancer.</p>

</s2>

<s2 title="Removing an elastic server">

<p>To remove an elastic server, just stop the server instance. The
triad will keep its place in the topology reserved for another 15
minutes to handle restarts, maintenance and outages. After the 15
minutes expire, the triad will automatically remove the server.</p>

</s2>

</s1>

<s1 title="Application Deployment">

<p>
Cloud deployments should generally use the cluster command-line (or browser)
deployment instead of dropping a .war in the webapps directory because
the cluster deployment automatically pushes deployment to new
servers.</p>

<p>With a cluster command-line deployment, the new server will check
with the triad hub for the latest deployment. If there's a new
version, the elastic server will download the updates from the triad
hub. The cluster deployment ensures all servers are running the same
.war deployment. You don't need external scripts to copy versions to
each server; that's taken care of by a core Resin capability.</p>

<example title="Example: command-line deployment">
unix> bin/resin.sh deploy test.war
</example>

<p>If you don't have a &lt;resin-system-auth-key> and do have
administrator users configured, you will also need to pass the -user
and -password parameters.</p>

<s2 title="Configuration for cluster deployment">

<p>The basic configuration for cluster deployment is the same as
for single-server deployment. Resin uses the same &lt;web-app-deploy>
tag to specify where cluster deployment should be expanded. If for
some reason you deploy a .war in the webapps directory and deploy one
on the clustered command-line, the cluster will take priority.</p>

<p>In the following example, a test.war deployed in the command-line
will be expanded to the webapps/test/ directory. The example uses
&lt;cluster-default> and &lt;host-default> so every cluster and every
virtual host can use the webapps deployment.</p>

<example title="Example: resin.xml cluster deployment">
&lt;resin xmlns="http://caucho.com/ns/resin">
...
&lt;cluster-default>
&lt;host-default>

  <b>&lt;web-app-deploy path="webapps"/></b>

&lt;/host-default>
&lt;/cluster-default>

&lt;cluster id="app-tier">
  ...
&lt;/cluster>
...
&lt;/resin>
</example>


</s2>

</s1>

<s1 title="Cluster Resources: Cache, Queues, Load-Balance">

<p>Resin's cluster-aware resources adapt to the added and removed
servers automatically. A new server can participate in the same clustered
cache as the cluster, see the same cache values, and update the cache
with entries visible to all the servers.</p>

<p>The Resin resources that are automatically cache-aware are:</p>

<ul>
<li>jcache: clustered caching</li>
<li>distributed sessions</li>
<li>JMS queues</li>
<li>load-balancing</li>
<li>administration</li>
<li>deployment</li>
</ul>

<s2 title="Clustered Caching configuration">

<p>Resin's clustered caching uses the jcache API, configured using
CDI XML syntax and injected with CDI. (It's also possible to use
JNDI.)</p>

<example title="Example: resin-web.xml Cluster cache configuration">
&lt;web-app xmlns="http://caucho.com/ns/resin"
            xmlns:resin="urn:java:com.caucho.resin">

  &lt;resin:ClusterCache name="my-cache"/>

&lt;/web-app>
</example>

<p>The cache can be used with CDI and standard injection:</p>

<example title="Example: using jcache">
package mypkg;

import javax.inject.*;
import javax.cache.*;

public class MyClass {
  @Inject
  private Cache&lt;String,String> _myCache;

  public void doStuff()
  {
    String value = _myCache.get("mykey");
  }
}  
</example>

</s2>

</s1>

</body>
</document>
