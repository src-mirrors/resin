<document>
<header>
<title>Java Dependency Injection (CanDI)</title>
<description>

<p>Resin is designed around the Java Dependency Injection specification
(JSR-299), an inversion-of-control framework used for all configuration
and resources including servlets, EJBs, messaging,
remoting, and databases.  Applications can take advantage of Java
Injection using standard annotations and interfaces.</p>

<p>Because Resin-DI is used for servlets, CanDI and EJBs, any application
bean can use EJB annotations like @TransactionAttribute or WebBeans
@InterceptionTypes or event @Observes capabilities, in addition to the
dependency injection and IoC configuration.</p>

<p>The dependency injection framework is type-safe, meaning the registry
is organized around Java types, not a flat namespace, which gives more
power and flexibility for component assembly.
Since injection is annotation-based, most components can avoid XML
configuration, while XML is still available for components.</p>

</description>
</header>
<body>

<localtoc/>

<s1 title="Overview">

<p>Resin's Java Injection support is integrated
with <a href="../doc/resin-ejb.xtp">EJB 3.0
</a> and the core components like Servlets, Filters and remote objects.
This integration means plain Java beans can use EJB annotations
and interception, EJBs can use Java Injection annotations, and both kinds of
beans can be configured directly from the <code>resin-web.xml</code>
or discovered by classpath scanning.</p>

<p>So it's best to think of Java Injection as a set of orthogonal
capabilities that
are available to any registered bean.  The basic capability types are:</p>

<ul>
<li><b>Lifecycle model:</b> Java, <code>@Stateless</code>, <code>@Stateful</code>,
or <code>@MessageDriven</code>.
Resin-managed objects like Servlets and Filters are Java model beans.</li>
<li><b>Dependency injection:</b> injection annotations from <code>javax.inject</code>: <code>@Current</code>, <code>@Named</code>, <code>@BindingType</code>, <code>@EJB</code>, <code>@PersistenceUnit</code>, etc are
available to all beans.</li>
<li><b>Registration:</b> all beans are registered in a unified typed-namespace
registry (i.e. the registration half of dependency injection.)</li>
<li><b>Lifecycle events:</b> the <code>@PostConstruct</code> and <code>@PreDestroy</code></li>
<li><b>Predefined aspects:</b> the <code>@TransactionAttribute</code>, <code>@RunAs</code>, <code>@RolesAllowed</code>, etc. annotations are
available to all beans.</li>
<li><b>Custom interceptors:</b> EJB-style <code>@AroundInvoke</code>, and <code>@Interceptors</code>, as well
as Java Injection <code>@Interceptor</code>, <code>@InterceptorBindingType</code>, and <code>@Decorator</code> are available to all beans.</li>
<li><b>Event handling:</b> the Java Injection <code>javax.event</code>, <code>@Observes</code> capability is available to all beans.</li>
</ul>
</s1>

<s1 title="XML configuration">

<p>You can register your components and services with Resin using the
resin.xml or resin-web.xml files as well as the META-INF/beans.xml.
Since the Java Injection registry is integrated
with Resin, your services be treated as first-class components along with
the Resin resources.  Although most components will not need XML, there
are a few advantages for the small number of services which do use XML.</p>

<p>The XML-configuration lets you customize your application for a
particular environment, e.g. setting configuration parameters.  For example,
Resin's <code>&lt;database></code> needs to select a database driver and
configure the URL, user and password of the database as well as configuring
connection pooling parameters.  Some application services will also need
configuration.</p>

<p>In addition, the XML-configuration documents the services
you've enabled.  For heavyweight services, this documentation is critical,
while lightweight components do not need this extra housekeeping overhead.</p>

<s2 title="Component overview">

<deftable title="Component/Bean configuration template">
<tr>
<td>
<code><pre>
&lt;web-app xmlns="http://caucho.com/ns/resin"
         xmlns:mypkg="urn:java:com.mycom.mypkg">
	   
  &lt;mypkg:MyBean>
    [class annotations, service, and registration]
    
    [bean constructor args]
    
    [property configuration]
    
    [method annotation configuration]
  &lt;/mypkg:MyBean>
  
&lt;/web-app>
</pre></code>
</td></tr>
</deftable>

<ol>
<li>The Bean/Component name and package is the Java class which implements
the resource you're configuring, either your own application class, or a
library class.</li>
<li>The class annotations register up the bean using a binding-type, or
a name and may register the bean as a service, like a servlet, or EJB or
remote service.</li>
<li>The optional bean constructor args are needed for some specialized
beans.  The application or library JavaDocs will document if you need to
use the constructor.</li>
<li>The properties configure the bean, like setting a database's url or
max-connections.  Each XML tag represents a bean property, and matches
exactly with the bean's JavaDoc.</li>
<li>The optional and rare method annotations are for special cases
like aspect-oriented interception.  Typically, these annotations are
configured by the library developers.</li>
</ol>

</s2>

<s2 title="bean and component registration">

<p>The <code>&lt;my:MyBean></code> tags register
application classes with Resin.
The default scope of a <code>&lt;my:MyBean></code> is <code>@Dependent</code>.
A <code>&lt;my:MyBean></code> will create a new instance each time it's
injected or referenced.</p>

<example title="Example: bean and component META-INF/beans.xml">
&lt;Beans xmlns="urn:java:ee" xmlns:example="urn:java:example">

  &lt;example:MyService>
    &lt;ApplicationScoped/>
  &lt;/example:MyService>

  &lt;example:MyComponent>
  &lt;/example:MyComponent>

&lt;/Beans>
</example>

<p>The <code>&lt;my:MyBean></code> tags can configure fields and
annotations:</p>

<deftable title="XML annotations">
<tr>
  <th>Attribute</th>
  <th>Description</th>
</tr>
<tr>
  <td>&lt;Named></td>
  <td>the <code>@javax.annotation.Name</code> annotations for EL naming</td>
</tr>
<tr>
  <td>&lt;BindingType></td>
  <td>any <code>@javax.annotation.BindingType</code> annotations for
  injection</td>
</tr>
<tr>
  <td>my:myField</td>
  <td>optional configuration, using bean-style assignment</td>
</tr>
<tr>
  <td>&lt;SessionScoped></td>
  <td>specifies scope of the instances: request, conversation, session, application, or singleton</td>
</tr>
</deftable>

</s2>

<s2 title="Bean property configuration">

<p>Resin's Java Injection configuration uses the standard JavaBeans
patterns to configure properties.  Resin uses the same mechanism for all of
its own configuration parsing, including every JavaEE configuration file, the
resin-web.xml and the resin.xml itself.  So your application will have
all the configuration flexibility it needs.</p>

<p>Since the component beans can use Java
Injections, injected components are typically not configured in
the resin-web.conf, avoiding the need for tags like <code>&lt;ref></code>.</p>

<example title="Example: Hello.java">
package example;

public class Hello {
  private String _greeting = "default";

  public void setGreeting(String greeting) { _greeting = greeting; }
  public String getGreeting() { return _greeting; }
}
</example>

<p>The basic example sets a <code>greeting</code> property of a hello, world
bean.  Resin will
apply the configuration to the instance as part of the creation process.</p>

<example title="Example: META-INF/beans.xml configuring a singleton">
&lt;Beans xmlns="urn:java:ee" xmlns:example="urn:java:example">

  &lt;example:Hello>
    &lt;example:greeting>Hello, World&lt;/example:greeting>
  &lt;/example:Hello>

&lt;/Beans>
</example>

<p>Resin's configuration uses 5 basic bean patterns, extending the JavaBeans
conventions.  It can configure literal values like string and integers as
well as configuring other beans.  Any component bean configured by Resin
has full access to <code>@BindingType</code> injection as well as
the standard <code>@PostConstruct</code> annotations.  Sub-beans are
not automatically registered with Java Inection, i.e. they act like the
servlet configuration.</p>

<p>(Currently the patterns are name-based like JavaBeans, since Resin
was designed before annotations.  We may add configuration annotations
in the future.</p>

<example title="Example: Bean configuration patterns">
  public void setFoo(String data);

  public void setFoo(Movie data);

  public void addFoo(Movie data);

  public Movie createFoo();

  public void setText(String data);
</example>

<ol>
<li><code>setFoo(String)</code> configures a standard JavaBeans-style
literal.</li>
<li><code>setFoo(Movie)</code> creates a new instance of <code>Movie</code> and recursively configures it.</li>
<li><code>addFoo(Movie)</code> also creates a new instance of <code>Movie</code> and recursively configures it.  <code>addFoo</code> is an easy way of
configuring lists.</li>
<li><code>Movie createFoo()</code> lets the bean create
the <code>Movie</code> instance.  Many beans can
use <code>createFoo</code> with inner classes to
handle complex configuration.</li>
<li><code>setText</code> is called with the text contents of
the XML.  Value-style beans will use this.  (somewhat rare).</li>
</ol>

<p>As mentioned above, Resin uses these 5 patterns to handle all of the
JavaEE configuration files.  In particular, the <code>createFoo</code>
pattern returning inner classes is very handy for some complicated
configuration cases, and for cases where a sub-tag needs information about
the parent.</p>

<example title="Example: sub-bean configuration example">
&lt;web-app xmlns="http://caucho.com/ns/resin">

  &lt;example:Theater xmlns:example="urn:java:example">
    &lt;example:name>Balboa&lt;/example:name>

    &lt;example:movie title="The Princess Bride"/>

    &lt;example:movie title="The Maltese Falcon"/>
  &lt;/example:Theater>

&lt;/web-app>
</example>

<p>In this example, the <code>Theater</code> classes uses
an inner <code>Movie</code> class to illustrate the use of
the <code>create</code> pattern.</p>

<example title="Example: Theater.java">
public class Theater {
  String _name;

  ArrayList&lt;Movie> _movies = new ArrayList&lt;Movie>();

  public void setName(String name) { _name = name; }

  public Movie createMovie()
  {
    return new Movie(this);
  }

  public void addMovie(Movie movie)
  {
    _movies.add(movie);
  }

  public static class Movie {
    private Theater _theater;
    private String _title;

    Movie(Theater theater)
    {
      _theater = theater;
    }

    public void setTitle(String title) { _title = title; }
  }
}
</example>

</s2>

<s2 title="Base configuration: string conversions">

<p>Java Injection provides a number of built-in string conversion types as well
as supporting JavaBeans <code>PropertyEditor</code> and custom converters.</p>

<deftable title="Built-in String Converters">
<tr>
  <th>Type</th>
  <th>Description</th>
</tr>
<tr>
  <td>boolean, Boolean</td>
  <td>Java boolean</td>
</tr>
<tr>
  <td>byte, Byte</td>
  <td>Java byte</td>
</tr>
<tr>
  <td>short, Short</td>
  <td>Java short</td>
</tr>
<tr>
  <td>int, Integer</td>
  <td>Java integer</td>
</tr>
<tr>
  <td>long, Long</td>
  <td>Java long</td>
</tr>
<tr>
  <td>float, Float</td>
  <td>Java float</td>
</tr>
<tr>
  <td>double, Double</td>
  <td>Java double</td>
</tr>
<tr>
  <td>char, Character</td>
  <td>Java char</td>
</tr>
<tr>
  <td>String[]</td>
  <td>String array separated by commas</td>
</tr>
<tr>
  <td>Class</td>
  <td>Java classes</td>
</tr>
<tr>
  <td>Path</td>
  <td>Resin VFS Paths</td>
</tr>
<tr>
  <td>File</td>
  <td>java.io.File</td>
</tr>
<tr>
  <td>URL</td>
  <td>java.net.URL</td>
</tr>
<tr>
  <td>Pattern</td>
  <td>java.util.regex.Pattern</td>
</tr>
<tr>
  <td>Locale</td>
  <td>java.util.Locale</td>
</tr>
<tr>
  <td>Date</td>
  <td>java.util.Date</td>
</tr>
<tr>
  <td>Properties</td>
  <td>java.util.Properties</td>
</tr>
<tr>
  <td>RawString</td>
  <td>com.caucho.config.type.RawString</td>
</tr>
</deftable>

<s3 title="enumerations">

<p>Enumerations are automatically converted from their
string representation.</p>

</s3>

<s3 title="String constructor">

<p>Resin-IoC will automatically convert a string to an object if the
object has a single String argument constructor.</p>

<example title="Example: MyBean with constructor">
public class MyBean {
  public MyBean(String value)
  {
    ...
  }
}
</example>

</s3>

<s3 title="valueOf">

<p>For classes which implement a static <code>valueOf(String)</code> method,
Resin will automatically convert to the given type using
the <code>valueOf</code> method.</p>

<example title="Example: MyBean with valueOf">
public class MyBean {
  ...

  public static MyBean valueOf(String text)
  {
    MyBean bean = new MyBean();
    bean.setTextValue(text);
    bean.init();
    return bean;
  }
}
</example>

</s3>

<s3 title="setValue">

<p>For objects with a <code>setValue</code> or <code>addText</code> method
and a zero-argument constructor, Resin-IoC will convert using the
following steps:</p>

<ol>
<li>Create the object</li>
<li>Inject any dependencies</li>
<li>Call <code>setValue</code> or <code>setText</code> with the string</li>
<li>Call any @PostConstruct</li>
<li>Return the configured bean</li>
</ol>

</s3>

</s2>

<s2 title="Compound types">

<s3 title="list">

<p>Setters taking a <code>List</code> or array argument can be configured
with list values.</p>

<p>List items are specified directly with &lt;value> elements.  There is
no extra &lt;list> element required.  The &lt;list> element is only used
when creating a sub-list or sub-element (see below.)</p>

<example title="Example: MyBean.setValues(List)">
&lt;my-bean>
  &lt;values>
    &lt;value>a&lt;/value>
    &lt;value>b&lt;/value>
    &lt;value>c&lt;/value>
  &lt;/values>
&lt;/my-bean>
</example>

<example title="Example: MyBean.setValues(String [])">
&lt;my-bean>
  &lt;values>
    &lt;value>a&lt;/value>
    &lt;value>b&lt;/value>
    &lt;value>c&lt;/value>
  &lt;/values>
&lt;/my-bean>
</example>

<p>In the following example, the argument is an object, so we need
a &lt;list> element to tell Resin to create a list.  The object
created will be an <code>ArrayList</code>.</p>
<example title="Example: MyBean.setValues(Object)">
&lt;my-bean>
  &lt;values>
    &lt;list>
      &lt;value>a&lt;/value>
      &lt;value>b&lt;/value>
      &lt;value>c&lt;/value>
    &lt;/list>
  &lt;/values>
&lt;/my-bean>
</example>

<p>Resin-IoC can always use the <code>addXXX</code> pattern to add
a variable number of items.  Normally, the <code>addXXX</code> pattern
is easier and more maintainable than the <code>addList</code> pattern.
In particular, validation of the item values is quicker and more accurate
with <code>addXXX</code>.</p>

<example title="Example: MyBean.addValue(String)">
&lt;my-bean>
  &lt;value>a&lt;/value>
  &lt;value>b&lt;/value>
  &lt;value>c&lt;/value>
&lt;/my-bean>
</example>

</s3>

<s3 title="map">

<p>Generic maps can use an &lt;entry> syntax to define property values.</p>

<example title="Example: MyBean.setValues(Map)">
&lt;my-bean>
  &lt;values>
    &lt;entry key="a" value="one"/>
    &lt;entry key="b" value="two"/>
    &lt;entry key="c" value="three"/>
  &lt;/values>
&lt;/my-bean>
</example>

</s3>

</s2>

<s2 title="References and EL Expressions">

<p>Resin-IoC configuration files can use EL expressions to get references
to resources, beans, system properties, and calculate generatal expressions
based on those values.  Since all Resin's resources are added to
the WebBeans registry automatically, application components have access to
anything they need.</p>

<p>Both the JSP immediate syntax and deferred syntax are
supported (${...} vs #{...}).  Currently, there is no distinction
between the two, but the deferred syntax is preferred, since Resin-IoC
initializes beans lazily to handle circular references.</p>

<example title="Example: circular references in resin-web.xml">
&lt;web-app xmlns="http://caucho.com/ns/resin"
       xmlns:qa="urn:java:qa">

  &lt;qa:FooBean>
    &lt;Named>a&lt;/Named>
    &lt;qa:bar>#{b}&lt;/qa:bar>
  &lt;/qa:FooBean>

  &lt;qa:FooBean>
    &lt;Named>b&lt;/Named>
    &lt;qa:bar>#{a}&lt;/qa:bar>
  &lt;/qa:FooBean>

&lt;/web-app>
</example>

<p>Because Resin's EL implementation allows method expressions, you can
use beans as factories in the EL expressions.</p>

</s2>

</s1>

<s1 title="Custom Services">

<p>Some of your application's beans will be configured as custom
services, like Java servlets or Hessian services, using CanDI to
configure a service annotation.  These custom services combine your own
Java code with Resin capabilities, usually to expose them as external web
services.
</p>

<deftable title="Custom Service Configuration">
<tr>
  <th>Annotation</th>
  <th>Description</th>
  <th>Sample</th>
</tr>

<tr>
  <td>
    <a href="http://caucho.com/resin-4.0-javadoc/com/caucho/remote/BamService.html">@BamService</a>
  </td>
  <td>BAM service</td>
  <td>
<pre><code>
&lt;mypkg:MyBean>
  &lt;resin:BamService name="my-service"/>
&lt;/mypkg:MyBean>
</code></pre>
  </td>
</tr>

<tr>
  <td>
    <a href="http://caucho.com/resin-4.0-javadoc/com/caucho/remote/HessianClient.html">@HessianClient</a>
  </td>
  <td>Hessian client proxy</td>
  <td>
<pre><code>
&lt;mypkg:MyApi>
  &lt;resin:HessianClient
               url="http://localhost:8080/test"/>
&lt;/mypkg:MyApi>
</code></pre>
  </td>
</tr>

<tr>
  <td>
    <a href="http://caucho.com/resin-4.0-javadoc/com/caucho/remote/HessianService.html">@HessianService</a>
  </td>
  <td>Hessian service</td>
  <td>
<pre><code>
&lt;mypkg:MyBean>
  &lt;resin:HessianService urlPattern="/test"/>
&lt;/mypkg:MyBean>
</code></pre>
  </td>
</tr>

<tr>
  <td>
    <a href="http://caucho.com/resin-4.0-javadoc/com/caucho/jms/JmsListener.html">@JmsListener</a>
  </td>
  <td>JMS based EJB message driven bean</td>
  <td>
<pre><code>
&lt;mypkg:MyBean>
  &lt;resin:JmsListener destination="my_queue"/>
&lt;/mypkg:MyBean>
</code></pre>
  </td>
</tr>

<tr>
  <td>
    <a href="http://caucho.com/resin-4.0-javadoc/javax/ejb/MessageDriven.html">@MessageDriven</a>
  </td>
  <td>EJB message driven bean</td>
  <td>
<pre><code>
&lt;mypkg:MyBean>
  &lt;ee:MessageDriven>
    &lt;ee:activationConfig
               propertyName="destination"
               propertyValue="my_queue"/>
  &lt;/ee:MessageDriven>
&lt;/mypkg:MyBean>
</code></pre>
  </td>
</tr>

<tr>
  <td>
    <a href="http://caucho.com/resin-4.0-javadoc/javax/ejb/Startup.html">@Startup</a>
  </td>
  <td>Start on initialization</td>
  <td>
<pre><code>
&lt;mypkg:MyBean>
  &lt;ee:Startup/>
&lt;/mypkg:MyBean>
</code></pre>
  </td>
</tr>

<tr>
  <td>
    <a href="http://caucho.com/resin-4.0-javadoc/javax/ejb/Stateful.html">@Stateful</a>
  </td>
  <td>EJB stateful session bean</td>
  <td>
<pre><code>
&lt;mypkg:MyBean>
  &lt;ee:Stateful/>
&lt;/mypkg:MyBean>
</code></pre>
  </td>
</tr>

<tr>
  <td>
    <a href="http://caucho.com/resin-4.0-javadoc/javax/ejb/Stateless.html">@Stateless</a>
  </td>
  <td>EJB stateless session bean</td>
  <td>
<pre><code>
&lt;mypkg:MyBean>
  &lt;ee:Stateless/>
&lt;/mypkg:MyBean>
</code></pre>
  </td>
</tr>

<tr>
  <td>
    <a href="http://caucho.com/resin-4.0-javadoc/javax/servlet/annotation/WebServlet.html">@WebServlet</a>
  </td>
  <td>Servlet mapping</td>
  <td>
<pre><code>
&lt;mypkg:MyServlet>
  &lt;ee:WebServlet value="/test"/>
&lt;/mypkg:MyServlet>
</code></pre>
  </td>
</tr>

</deftable>


</s1>

</body>
</document>
