<document>
<header>
<title>Injection-Based Resource Configuration (CanDI)</title>
<description>

<p>Resin's configuration uses a powerful, general dependency
injection system (CanDI) to configure servlets, Resin resources, databases,
application components, third-party libraries and drivers.  By understanding
a few rules matching the XML to the configured resources, an administrator
can have full control over the application server behavior.</p>

<p>Because of the importance of verifying and debugging configuration,
Resin's configuration is stateless, meaning that the XML files fully
describe the configuration of the system.  Resin avoids hidden state
by avoiding deployment tools and internal, hidden database configuration.</p>

</description>
</header>
<body>

<localtoc/>

<s1 title="Overview">

<p>Because Resin's configuration (CanDI) creates and updates Java objects,
each XML tag exactly matches either a Java class or a Java property.
For security and rewrite rules, the JavaDoc helps document the
configuration.  Your own application's configuration can use its
JavaDoc to describe the XML tags, and Resin's configuration files
like the META-INF/resin-web.xml to customize your application.</p>

<ul>
<li>
  <b>Selecting drivers and services:</b> by specifying the Java class,
  like choosing a JDBC database driver, or application services.  The
  Java classes should be self-documented in the application's JavaDoc.
</li>
<li>
  <b>Configuring properties:</b> with XML values for each important
  property of the Java class, like setting URLs, timeouts, and
  connection limited.  More complicated configuration is supported
  allowing configuration similar to domain-specific languages, for
  example Resin's rewrite rules and security configuration.
</li>
<li>
  <b>Registration for the application:</b> the application looks up
  configured resources either through Java Injection or in JNDI.  The
  application will already have defined names and binding types for
  the XML configuration to use.
</li>
<li>
  <b>Linking references:</b> in some more complicated applications,
  the configuration can link resources and services together using the
  JSP expression language, specifying resources by name like
  #{myResource}.
</li>  
</ul>

</s1>

<s1 title="XML configuration">

<p>Services, drivers, and third-party libraries are registered and
configured using the standard Resin configuration files
resin.xml or resin-web.xml files as well as the META-INF/beans.xml.
Application services and libraryes are treated as first-class
components just like Resin-internal resources, because Resin's own
configuration uses the same CanDI configuration.  Even standard JavaEE
configuration like servlets, JSP .tld files, and EJBs are configured
with CanDI.</p>

<p>The configuration in Resin is smaller than some other dependency
frameworks because only components which need customization need to be
in the XML.  If your application is using Java Injection internally,
most of the wiring occurs automatically through Java code annotations
instead of being configured in XML.  The annotation focus makes the
Java code self-describing, and also simplifies the management by
shrinking the needed XML.</p>

<p>The XML-configuration lets you customize your application for a
particular environment, e.g. setting configuration parameters.  For example,
Resin's <code>&lt;database></code> needs to select a database driver and
configure the URL, user and password of the database as well as configuring
connection pooling parameters.  Some application services will also need
configuration.</p>

<p>In addition, the XML-configuration documents the services
you've enabled.  For heavyweight services, this documentation is critical,
while lightweight components do not need this extra housekeeping overhead.</p>

<s2 title="Component overview">

<deftable title="Component/Bean configuration template">
<tr>
<td>
<code><pre>
&lt;web-app xmlns="http://caucho.com/ns/resin"
         xmlns:mypkg="urn:java:com.mycom.mypkg">
	   
  &lt;mypkg:MyBean>
    [class annotations, service, and registration]
    
    [bean constructor args]
    
    [property configuration]
    
    [method annotation configuration]
  &lt;/mypkg:MyBean>
  
&lt;/web-app>
</pre></code>
</td></tr>
</deftable>

<ol>
<li>The Bean/Component name and package is the Java class which implements
the resource you're configuring, either your own application class, or a
library class.</li>
<li>The class annotations register up the bean using a binding-type, or
a name and may register the bean as a service, like a servlet, or EJB or
remote service.</li>
<li>The optional bean constructor args are needed for some specialized
beans.  The application or library JavaDocs will document if you need to
use the constructor.</li>
<li>The properties configure the bean, like setting a database's url or
max-connections.  Each XML tag represents a bean property, and matches
exactly with the bean's JavaDoc.</li>
<li>The optional and rare method annotations are for special cases
like aspect-oriented interception.  Typically, these annotations are
configured by the library developers.</li>
</ol>

</s2>
</s1>

<s1 title="Service and component registration">

<p>The <code>&lt;my:MyBean></code> tags register
application classes with Resin.
The default scope of a <code>&lt;my:MyBean></code> is <code>@Dependent</code>.
A <code>&lt;my:MyBean></code> will create a new instance each time it's
injected or referenced.</p>

<example title="Example: bean and component META-INF/beans.xml">
&lt;Beans xmlns="urn:java:ee" xmlns:example="urn:java:example">

  &lt;example:MyService>
    &lt;ApplicationScoped/>
  &lt;/example:MyService>

  &lt;example:MyComponent>
  &lt;/example:MyComponent>

&lt;/Beans>
</example>

<p>The <code>&lt;my:MyBean></code> tags can configure fields and
annotations:</p>

<deftable title="XML annotations">
<tr>
  <th>Attribute</th>
  <th>Description</th>
</tr>
<tr>
  <td>&lt;Named></td>
  <td>the <a href="http://caucho.com/resin-javadoc/javax/enterprise/inject/Named.html">@javax.enterprise.inject.Named</a> annotations for EL naming</td>
</tr>
<tr>
  <td>&lt;BindingType></td>
  <td>any <a href="http://caucho.com/resin-javadoc/javax/enterprise/inject/BindingType">@javax.enterprise.inject.BindingType</a> annotations for
  injection</td>
</tr>
<tr>
  <td>my:myField</td>
  <td>optional configuration, using bean-style assignment</td>
</tr>
<tr>
  <td>&lt;SessionScoped></td>
  <td>specifies scope of the instances: request, conversation, session, application, or singleton</td>
</tr>
</deftable>

</s1>

<s1 title="References and EL Expressions">

<p>Some services and components need a name because they're used as a
JSP or JSF reference, or because the configuration needs a reference
to the component.  Resin configuration files can use EL expressions to
get references to resources, beans, system properties, and calculate
generatal expressions based on those values.  Because all Resin's
resources are added to the CanDI registry automatically, application
components have access to anything they need.</p>

<p>Both the JSP immediate syntax and deferred syntax are
supported (<code>${...}</code> vs <code>#{...}</code>).  Currently,
there is no distinction between the two, but the deferred syntax
is preferred, because CanDI initializes beans lazily to handle
circular references.</p>

<example title="Example: circular references in resin-web.xml">
&lt;web-app xmlns="http://caucho.com/ns/resin"
       xmlns:qa="urn:java:qa">

  &lt;qa:FooBean>
    &lt;Named>a&lt;/Named>
    &lt;qa:bar>#{b}&lt;/qa:bar>
  &lt;/qa:FooBean>

  &lt;qa:FooBean>
    &lt;Named>b&lt;/Named>
    &lt;qa:bar>#{a}&lt;/qa:bar>
  &lt;/qa:FooBean>

&lt;/web-app>
</example>

<p>You can also use beans as factories in the EL expressions, because
Resin's EL implementation allows method expressions.  If the bean's
create method is named <code>create()</code>, the EL
expression will look something like <code>#{foo.create()}</code>.</p>

</s1>

<s1 title="Property configuration">

<p>Resin's Java Injection configuration uses the standard JavaBeans
patterns to configure properties.  Resin uses the same mechanism for all of
its own configuration parsing, including every JavaEE configuration file, the
resin-web.xml and the resin.xml itself.  So your application will have
all the configuration flexibility it needs.</p>

<p>Since the component beans can use Java
Injections, injected components are typically not configured in
the resin-web.conf, avoiding the need for tags like <code>&lt;ref></code>.</p>

<example title="Example: Hello.java">
package example;

public class Hello {
  public void setGreeting(String greeting);
}
</example>

<p>The basic example sets a <code>greeting</code> property of a hello, world
bean.  Resin will
apply the configuration to the instance as part of the creation process.</p>

<example title="Example: META-INF/beans.xml configuring a singleton">
&lt;Beans xmlns="urn:java:ee" xmlns:example="urn:java:example">

  &lt;example:Hello>
    &lt;example:greeting>Hello, World&lt;/example:greeting>
  &lt;/example:Hello>

&lt;/Beans>
</example>

<s2 title="primitive conversions">

<p>Resin automatically converts XML values to the Java property types
for most primitive values.  For other primitive types, it also supports
the JavaBeans <code>PropertyEditor</code> and custom converters.</p>

<deftable title="Built-in String Converters">
<tr>
  <th>Type</th>
  <th>Examples</th>
</tr>
<tr>
  <td>String</td>
  <td>hello, world</td>
</tr>
<tr>
  <td>boolean</td>
  <td>true, false</td>
</tr>
<tr>
  <td>numbers</td>
  <td>3, -4, 3.14, 9.3e-20</td>
</tr>
<tr>
  <td>char</td>
  <td>a, b</td>
</tr>
<tr>
  <td>String[]</td>
  <td>foo, bar, baz</td>
</tr>
<tr>
  <td>Class</td>
  <td>com.foo.MyBean</td>
</tr>
<tr>
  <td>Path</td>
  <td>file:/var/data/file</td>
</tr>
<tr>
  <td>File</td>
  <td>/var/data/file</td>
</tr>
<tr>
  <td>URL</td>
  <td>http://hessian.caucho.com/test</td>
</tr>
<tr>
  <td>Pattern</td>
  <td>a+[bcd]*</td>
</tr>
<tr>
  <td>Date</td>
  <td>2009-07-14 10:13</td>
</tr>
<tr>
  <td>Properties</td>
  <td>a=value</td>
</tr>
<tr>
  <td>Enumeration</td>
  <td>RED, BLUE</td>
</tr>
</deftable>

<s3 title="enumerations">

<p>Enumerations are automatically converted from their
string representation.</p>

</s3>

</s2>

<s2 title="compound types">

<p>Full sub-bean configuration is also available when a service needs
a more complicated configuration than primitives allow.  The service
class can add sub-beans as properties and the sub-beans themselves are
configured recursively using Resin's configuration.  Since all JavaEE
configuration files like the web.xml and the *.tld files are
configured using Resin's recursive sub-bean configuration, your
application has full access to a powerful recursive configuration.</p>

<p>A sophisticated application can use Resin's sub-bean configuration
to create a full domain-specific language, allowing extensive user
control of the application.</p>

<s3 title="custom sub-beans">

<example title="Example: sub-bean configuration example">
&lt;web-app xmlns="http://caucho.com/ns/resin">

  &lt;example:Theater xmlns:example="urn:java:example">
    &lt;example:name>Balboa&lt;/example:name>

    &lt;example:movie title="The Princess Bride"/>

    &lt;example:movie title="The Maltese Falcon"/>
  &lt;/example:Theater>

&lt;/web-app>
</example>

<p>In this example, the <code>Theater</code> is configured with
multiple <code>Movie</code> classes, each added with the
<code>addMovie</code> method.</p>

<example title="Example: Theater.java">
public class Theater {
  public void setName(String name);

  public void addMovie(Movie movie)
}
</example>

<example title="Example: Movie.java">
public class Movie {
  public void setTitle(String title);
}
</example>

</s3>

<s3 title="list">

<p>Setters taking a <code>List</code> or array argument can be configured
with list values.</p>

<p>List items are specified directly with &lt;value> elements.  There is
no extra &lt;list> element required.  The &lt;list> element is only used
when creating a sub-list or sub-element (see below.)</p>

<example title="Example: MyBean.setValues(List)">
&lt;my-bean>
  &lt;values>
    &lt;value>a&lt;/value>
    &lt;value>b&lt;/value>
    &lt;value>c&lt;/value>
  &lt;/values>
&lt;/my-bean>
</example>

<example title="Example: MyBean.setValues(String [])">
&lt;my-bean>
  &lt;values>
    &lt;value>a&lt;/value>
    &lt;value>b&lt;/value>
    &lt;value>c&lt;/value>
  &lt;/values>
&lt;/my-bean>
</example>

<p>In the following example, the argument is an object, so we need
a &lt;list> element to tell Resin to create a list.  The object
created will be an <code>ArrayList</code>.</p>
<example title="Example: MyBean.setValues(Object)">
&lt;my-bean>
  &lt;values>
    &lt;list>
      &lt;value>a&lt;/value>
      &lt;value>b&lt;/value>
      &lt;value>c&lt;/value>
    &lt;/list>
  &lt;/values>
&lt;/my-bean>
</example>

<p>Resin can always use the <code>addXXX</code> pattern to add
a variable number of items.  Normally, the <code>addXXX</code> pattern
is easier and more maintainable than the <code>addList</code> pattern.
In particular, validation of the item values is quicker and more accurate
with <code>addXXX</code>.</p>

<example title="Example: MyBean.addValue(String)">
&lt;my-bean>
  &lt;value>a&lt;/value>
  &lt;value>b&lt;/value>
  &lt;value>c&lt;/value>
&lt;/my-bean>
</example>

</s3>

<s3 title="map">

<p>Generic maps can use an &lt;entry> syntax to define property values.</p>

<example title="Example: MyBean.setValues(Map)">
&lt;my-bean>
  &lt;values>
    &lt;entry key="a" value="one"/>
    &lt;entry key="b" value="two"/>
    &lt;entry key="c" value="three"/>
  &lt;/values>
&lt;/my-bean>
</example>

</s3>

</s2>

</s1>

<s1 title="Constructors">

<p>Some beans require constructor configuration because the service or
library designer prefers constructors to method configuration.
Resin's configuration can support these constructor beans with the
<code>&lt;new></code> syntax.</p>

<example title="Example: MyBean configuration">
&lt;web-app xmlns="http://caucho.com/ns/resin"
            xmlns:example="urn:java:example">
	    
  &lt;example:MyBean>
    &lt;new>
      &lt;value>first arg&lt;value>
      &lt;value>second arg&lt;value>
    &lt;/new>
  &lt;/example:MyBean>

&lt;/web-app>
</example>

<example title="Example: MyBean with constructor">
public class MyBean {
  public MyBean(String a, String b)
  {
    ...
  }
}
</example>

<s2 title="Single constructor">

<p>As a convenience, Resin provides short form of the constructor
configuration if there's only a single argument.  You can either omit
the &lt;value> and just use the &lt;new> tag, or you can even omit the
&lt;new> tag entirely.</p>

<example title="Example: MyBean short form">
&lt;web-app xmlns="http://caucho.com/ns/resin"
            xmlns:example="urn:java:example">
	    
  &lt;example:MyBean>
    &lt;new>single arg&lt;/new>
  &lt;/example:MyBean>

&lt;/web-app>
</example>

<example title="Example: MyBean ultra-short form">
&lt;web-app xmlns="http://caucho.com/ns/resin"
            xmlns:example="urn:java:example">
	    
  &lt;example:MyBean>single arg&lt;example:MyBean>

&lt;/web-app>
</example>

</s2>

<s2 title="valueOf">

<p>For classes which implement a static <code>valueOf(String)</code> method,
Resin will automatically convert to the given type using
the <code>valueOf</code> method.</p>

<example title="Example: MyBean with valueOf">
public class MyBean {
  ...

  public static MyBean valueOf(String text)
  {
    MyBean bean = new MyBean();
    bean.setTextValue(text);
    bean.init();
    return bean;
  }
}
</example>

</s2>

<s2 title="setValue">

<p>For objects with a <code>setValue</code> or <code>addText</code> method
and a zero-argument constructor, Resin-IoC will convert using the
following steps:</p>

<ol>
<li>Create the object</li>
<li>Inject any dependencies</li>
<li>Call <code>setValue</code> or <code>setText</code> with the string</li>
<li>Call any @PostConstruct</li>
<li>Return the configured bean</li>
</ol>

</s2>

</s1>

<s1 title="Custom Services">

<p>Some of your application's beans will be configured as custom
services, like Java servlets or Hessian services, using CanDI to
configure a service annotation.  These custom services combine your own
Java code with Resin capabilities, usually to expose them as external web
services.
</p>

<deftable title="Custom Service Configuration">
<tr>
  <th>Annotation</th>
  <th>Description</th>
  <th>Sample</th>
</tr>

<tr>
  <td>
    <a href="http://caucho.com/resin-4.0-javadoc/com/caucho/remote/BamService.html">@BamService</a>
  </td>
  <td>BAM service</td>
  <td>
<pre><code>
&lt;mypkg:MyBean>
  &lt;resin:BamService name="my-service"/>
&lt;/mypkg:MyBean>
</code></pre>
  </td>
</tr>

<tr>
  <td>
    <a href="http://caucho.com/resin-4.0-javadoc/com/caucho/remote/HessianClient.html">@HessianClient</a>
  </td>
  <td>Hessian client proxy</td>
  <td>
<pre><code>
&lt;mypkg:MyApi>
  &lt;resin:HessianClient
               url="http://localhost:8080/test"/>
&lt;/mypkg:MyApi>
</code></pre>
  </td>
</tr>

<tr>
  <td>
    <a href="http://caucho.com/resin-4.0-javadoc/com/caucho/remote/HessianService.html">@HessianService</a>
  </td>
  <td>Hessian service</td>
  <td>
<pre><code>
&lt;mypkg:MyBean>
  &lt;resin:HessianService urlPattern="/test"/>
&lt;/mypkg:MyBean>
</code></pre>
  </td>
</tr>

<tr>
  <td>
    <a href="http://caucho.com/resin-4.0-javadoc/com/caucho/jms/JmsListener.html">@JmsListener</a>
  </td>
  <td>JMS based EJB message driven bean</td>
  <td>
<pre><code>
&lt;mypkg:MyBean>
  &lt;resin:JmsListener destination="my_queue"/>
&lt;/mypkg:MyBean>
</code></pre>
  </td>
</tr>

<tr>
  <td>
    <a href="http://caucho.com/resin-4.0-javadoc/javax/ejb/MessageDriven.html">@MessageDriven</a>
  </td>
  <td>EJB message driven bean</td>
  <td>
<pre><code>
&lt;mypkg:MyBean>
  &lt;ee:MessageDriven>
    &lt;ee:activationConfig
               propertyName="destination"
               propertyValue="my_queue"/>
  &lt;/ee:MessageDriven>
&lt;/mypkg:MyBean>
</code></pre>
  </td>
</tr>

<tr>
  <td>
    <a href="http://caucho.com/resin-4.0-javadoc/javax/ejb/Startup.html">@Startup</a>
  </td>
  <td>Start on initialization</td>
  <td>
<pre><code>
&lt;mypkg:MyBean>
  &lt;ee:Startup/>
&lt;/mypkg:MyBean>
</code></pre>
  </td>
</tr>

<tr>
  <td>
    <a href="http://caucho.com/resin-4.0-javadoc/javax/ejb/Stateful.html">@Stateful</a>
  </td>
  <td>EJB stateful session bean</td>
  <td>
<pre><code>
&lt;mypkg:MyBean>
  &lt;ee:Stateful/>
&lt;/mypkg:MyBean>
</code></pre>
  </td>
</tr>

<tr>
  <td>
    <a href="http://caucho.com/resin-4.0-javadoc/javax/ejb/Stateless.html">@Stateless</a>
  </td>
  <td>EJB stateless session bean</td>
  <td>
<pre><code>
&lt;mypkg:MyBean>
  &lt;ee:Stateless/>
&lt;/mypkg:MyBean>
</code></pre>
  </td>
</tr>

<tr>
  <td>
    <a href="http://caucho.com/resin-4.0-javadoc/javax/servlet/annotation/WebServlet.html">@WebServlet</a>
  </td>
  <td>Servlet mapping</td>
  <td>
<pre><code>
&lt;mypkg:MyServlet>
  &lt;ee:WebServlet value="/test"/>
&lt;/mypkg:MyServlet>
</code></pre>
  </td>
</tr>

</deftable>


</s1>

</body>
</document>
