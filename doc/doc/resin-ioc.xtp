<document>
<header>
<title>Resin Dependency Injection</title>
<description>

<p>Resin's dependency injection framework gives your application
a type-safe architecture for designing and assembling services and components.
Since injection is annotation-based, most components can avoid XML
configuration, while XML is still available for components.</p>

</description>
</header>
<body>

<localtoc/>

<s1 title="Injecting Resources">

<p>Before dependency injection, applications needed to use JNDI to
grab resources managed by Resin: database connections, JMS queues, JCA
<code>EntityManagers</code>, timers, <code>UserTransaction</code>, the
JMX <code>MBeanServer</code>, etc.  The JNDI lookup had two main
flaws: it required a good chunk of boilerplate code to solve a simple
problem, and it was untyped.  Since JNDI is essentially a big HashMap,
the only way of making sure your <code>DataSource</code> name didn't
conflict with your JMS <code>Queue</code> was strictly structuring the
JNDI names with patterns like <code>java:comp/env/jdbc/foo</code>.
</p>

<p>With dependency injection, Resin will lookup, verify and inject
the resource when it creates your managed class, for example when creating
a servlet.  In the following example, when Resin creates MyServlet, the <code>@In</code> annotation tells it to look for a <code>UserTransaction</code>
and <code>DataSource</code> and use reflection to set the fields,
before calling the servlet's <code>init()</code> method.</p>

<example>
import javax.sql.DataSource;
import javax.transaction.UserTransaction;
import javax.webbeans.In;

public class MyServlet extends GenericServlet {
  @In private DataSource _ds;
  @In private UserTransaction _ut;

  ...
}
</example>

<s2 title="@Named and bindings">

<p>Since many applications use multiple resources like named databases,
your injection may need to specify a name or other binding to uniquely
identify the resource you want.  In the case of a unique resource like
<code>UserTransaction</code> or <code>MBeanServer</code> or an application
with a single <code>DataSource</code>, the <code>@In</code> is enough
information.  When you have multiple databases, you'll want to
use <code>@Named</code> to specify the database name.</p>

<example>
import javax.sql.DataSource;
import javax.webbeans.Named;

public class MyServlet extends GenericServlet {
  @Named("foo") private DataSource _ds;

  ...
}
</example>
<example title="resin-web.xml database configuration">
&lt;web-app xmlns="http://caucho.com/ns/resin">

  &lt;database>
    &lt;name>foo&lt;/name>
    &lt;driver type="org.gjt.mm.mysql.Driver">
      &lt;url>jdbc:mysql://localhost:3306/foo&lt;/url>
    &lt;/driver>
  &lt;/database>

  &lt;database>
    &lt;name>bar&lt;/name>
    &lt;driver type="org.gjt.mm.mysql.Driver">
      &lt;url>jdbc:mysql://localhost:3306/bar&lt;/url>
    &lt;/driver>
  &lt;/database>

&lt;/web-app>
</example>

<p>Injection using a <code>@Named</code> binding annotation is still
typed.  You can have a database with <code>@Named("foo")</code> and
a JMS queue with <code>@Named("foo")</code>, i.e. each type has its own
namespace.  The typed injection is a big improvement from the JNDI
<code>java:comp/env/jdbc/foo</code> vs <code>java:comp/env/jms/foo</code>
conventions.</p>

<p>Although many applications will just use <code>@In</code>
and <code>@Named</code>, you can also create your
own <code>BindingType</code> annotations to match resources
and components.</p>

</s2>

<s2 title="field, method, and constructor injection">

<p>Since Resin implements all three flavors of dependency injection: field,
method and constructor, the choice of style is up to you.</p>

<p>You can mark any field with <code>@In</code>, <code>@New</code>,
<code>@Named</code> or any other <code>@BindingType</code> to tell Resin
to inject the field.  When a <code>@BindingType</code> is used, Resin will
only match components configured with that binding type.</p>

<example title="field injection">
import javax.webbeans.Named;

public class MyBean {
  @Named DataSource _ds;
  ...
}
</example>

<p>Method injection can use any binding annotation on any of the parameters.
When Resin introspects the component class and it finds
any <code>@BindingType</code> or <code>@In</code> parameter on a method, it
will add that schedule that method to be injected.  Method parameters can
also use <code>@New</code>.  The method does not need to follow bean-style
setting conventions; any method will work.</p>

<example title="method injection">
import javax.webbeans.Named;

public class MyBean {
  void foo(@Named("jdbc/foo") DataSource myDataSource) { ... }
  ...
}
</example>

<p>Construction injection is available for components and singleton beans.
Like method injection, the <code>@BindingType</code> values
like <code>@Named</code> assigned to the parameters determine the
values to be injected.</p>

<p>If the bean has multiple constructors, exactly one must be marked
<code>@In</code> or have a <code>@BindingType</code> value.</p>

<example title="constructor injection">
import javax.webbeans.In;

public class MyBean {
  @In
  public MyBean(DataSource myDataSource) { ... }
  ...
}
</example>

</s2>

<s2 title="WebBeans-enabled components (injectable objects)">

<p>Any Resin-managed object can use the entire WebBeans
dependency-injection system and all of the managed objects, while objects
you create using <code>new</code> are still plain Java objects.
Once you've got a root object managed by the system, any futher
WebBeans components or singletons you bring in will also be managed.
The starting set of managed objects is pretty broad and includes:</p>

<ul>
<li>&lt;bean> (singletons) defined in the resin.conf or resin-web.xml</li>
<li>&lt;component> (WebBeans components) defined in the resin.conf,
resin-web.xml or web-beans.xml</li>
<li>EJB message-driven beans</li>
<li>EJB session beans</li>
<li>Filters (servlet)</li>
<li>JSF resources (currently only model beans)</li>
<li>JSP pages</li>
<li>JSP tag libraries</li>
<li>&lt;resource> components (Resin will be migrating to use &lt;bean> for resources in the future.)</li>
<li>Servlets</li>
<li>Servlet Listeners defined in the web.xml</li>
<li>WebBeans annotated components (<code>@Component</code>)
discovered through the classpath scan (see below)</li>
<li>WebBeans components injected with <code>@New</code> (see below)</li>
<li>Remote services defined by &lt;servlet> (e.g. Hessian or SOAP).</li>
</ul>

</s2>

<s2 title="Resin global resources">

<p>Resin automatically provides several global resources to any
injectable code. Since these resources are unique, your application
will use <code>@In</code> as the annotation.</p>

<p><b><code>javax.webbeans.Container</code></b> provides a reference to
the WebBeans container itself.  Applications can use the
<code>Container</code> to raise <code>WebBeans</code> events, and
lookup components programmatically.</p>

<p><b><code>javax.webbeans.Conversation</code></b> injects the WebBeans
conversation scope for a JSF application.  The conversatio scope lets
JSF views store data local to the page itself, separate from the
HTTP session scope.</p>

<p><b><code>javax.management.MBeanServer</code></b> injects the JMX
management server.  JMX manages Resin's resources, so an application
can use JMX to view the current state of Resin.  See the
<a href="http://caucho.com/resin-javadoc/com/caucho/management/server/package-summary.html">JavaDoc</a> for an overview of Resin's resources.</p>

<p><b><code>javax.transaction.TransactionManager</code></b> injects the
XA transaction manager.  Advanced applications which want to add their
own <code>XAResource</code> or <code>Synchronization</code> objects
to an active transaction can use <code>@In TransactionManager</code>.</p>

<p><b><code>javax.transaction.UserTransaction</code></b> injects the
XA user transaction manager.  Applications controlling XA transactions
programmatically will use the <code>UserTransaction</code>
to <code>begin()</code>, <code>rollback()</code>, and
<code>commit()</code> distributed transactions.</p>

<p><b><code>java.util.concurrent.ScheduledExecutorService</code></b>
lets applications schedule threads and timed events controlled by
Resin's thread pool, and restricted by the thread-max configuration
in the resin.conf.  This <code>ScheduleExecutorService</code> is
classloader-safe, so Resin will automatically close your scheduled
tasks when restarting a web-app.</p>

</s2>

<s2 title="Resin configured resources">

<p>All Resin configured resources are available through WebBeans, since
Resin uses WebBeans as its internal registry.</p>

<p><b><code>&lt;bean></code></b> singletons are application-specific
custom services.  They are exactly like the &lt;component> beans but
default to singleton scope.  Like &lt;component> they can
either use WebBeans annotations or just be POJO objects.
The &lt;bean> tag makes the beans available to any other WebBeans
component.  The bean default to <code>@Singleton</code> scope, which
means that a unique instance is created at Resin start time.
The injected type will depend on the <code>class</code> attribute of
the bean.</p>

<p><b><code>&lt;component></code></b> objects are application-specific custom
beans.  They can either use WebBeans annotations or just be POJO objects.
The &lt;component> tag makes the beans available to any other WebBeans
component.  The components default to <code>@Dependent</code> scope, which
means a new instance is created each time they're referenced or injected.
The injected type will depend on the <code>class</code> attribute of
the bean.</p>

<p><b><code>&lt;database></code></b> is a JDBC pooled database.
The <code>name</code> attribute is assigned to the <code>@Named</code>
binding. Databases are injected as <code>javax.sql.DataSource</code> types.</p>

<p><b>EJB stateless beans</b> are automatically registered the
WebBeans.  The default <code>@Named</code> value is the ejb-name.
Stateless beans can use the &lt;ejb-stateless-bean> tag for custom
configuration, or rely on the standard EJB discovery mechanism.
Each EJB 3.0 <code>@Local</code> interface is registered separately
in the WebBeans registry.</p>

<p><b>EJB stateful beans</b> are automatically registered with
WebBeans.  The default <code>@Named</code> value is the ejb-name.
Stateful beans can use the &lt;ejb-stateful-bean> tag for custom
configuration, or rely on the standard EJB discovery mechanism.
Each injection or bean lookup will return a new stateful bean
reference, modified by the bean's scope (see below.)
Each EJB 3.0 <code>@Local</code> interface is registered separately
in the WebBeans registry.</p>

<p><b>EntityManager</b> and <b>EntityManagerFactory</b> objects
from JPA are automatically registered with WebBeans.  The default
<code>@Named</code> value is the <code>persistence-unit</code> name.</p>

<p><b>&lt;env-entry></b> tags register their values with
WebBeans.  The default <code>@Named</code> value is
the <code>env-entry-name</code>.  The registered type is the
<code>env-entry-type</code>.</p>

<p><b>&lt;jms-connection-factory></b> automatically registers the configured
factory with WebBeans. 
Connection factories can also be configured with &lt;bean> or &lt;resource>,
depending on the JMS provider.  The registered type is the <code>class</code>
of the connection factory, usually <code>javax.jms.ConnectionFactory</code></p>

<p><b>&lt;jms-topic></b> automatically registers the configured
topic with WebBeans.  The default <code>@Named</code> value is the
topic name.  Topic can also be configured with &lt;bean> or &lt;resource>,
depending on the JMS provider.  The registered type is
<code>javax.jms.Topic</code></p>

<p><b>&lt;jms-queue></b> automatically registers the configured
queue with WebBeans.  The default <code>@Named</code> value is the
queue name.  Queue can also be configured with &lt;bean> or &lt;resource>,
depending on the JMS provider.  The registered type is
<code>javax.jms.Queue</code></p>

<p><b>&lt;resource></b> automatically registers the configured
resource with WebBeans.  In the future, the resource tag will likely be
replaced by &lt;bean> instances.  The registered type is the resource
type.</p>

<p><b>&lt;web-service-client></b> registers remoting clients with WebBeans.
The &lt;web-service-client> tag will configure the protocol used and the
expected proxy class.  The registered type is the API <code>class</code>
of the remote service.</p>

<example title="resin-web.xml for web-service-client">
&lt;web-app xmlns="http://caucho.com/ns/resin">

  &lt;web-service-client class="example.HelloService">
    &lt;url>hessian:http://localhost:8080/hello/&lt;/url>
  &lt;/web-service-client>

&lt;/web-app>
</example>
<example title="Injecting for web-service-client">
public class MyServlet extends GenericServlet {
  @In example.HelloService _hello;
  ...
}
</example>

</s2>

</s1>

<s1 title="Application components">

<p>The primary value of Resin's dependency injection system is as a
type-safe component and service organization registry.  Module and
component-oriented software has been a goal of software developers
for decades, but in practice developing components and services is
a difficult task, in large part because the configuration and
assembly of the components has been just as
complicated as the code itself.  There are no silver bullets in software,
but the WebBeans registry does significatly reduce the housekeeping code
and XML which gets in the way of good design.</p>

<s2 title="Annotation-based Component Discovery">

<p>At startup, Resin will scan jars and class directories for a
<code>META-INF/web-beans.xml</code> file.  The presence of that file
tells Resin to start scanning all the classes in the jar or directory
for <code>@Component</code> annotations.  Resin will register each
class with a <code>@Component</code> market with the WebBeans directory.
The <code>META-INF/web-beans.xml</code> can be trivial, since its primary
purpose is speeding up startup time by letting Resin scan only the jars
which contain components.  So, applications will generally want to minimize
the number of classes in <code>@Component</code> jars to make
startup fast.</p>

<example title="META-INF/web-beans.xml">
&lt;web-beans xmlns="http://caucho.com/ns/resin">
&lt;/web-beans>
</example>

<p>The component itself can be any Java class.  Since Resin manages the
component, it can use <code>@In</code> and <code>@Named</code> to inject
any other component or resource.  Resin will take care of any circular
dependencies automatically.</p>

<example title="Movie.java">
import javax.annotation.PostConstruct;
import javax.webbeans.Component;

@Component
public class Movie {
  private String _title;
  private String _director;

  public String getTitle() { return _title; }
  public void setTitle(String title) { _title = _title; }

  public String getDirector() { return _director; }
  public void setDirector(String director) { _director = director; }

  @PostConstruct
  public void init()
  {
    ...
  }
}
</example>

<p>The <code>@PostConstruct</code> annotation tells Resin to call the
<code>init()</code> method once all the injection and configuration is
complete.</p>

<p>Any other component or Resin-managed class like servlets can now
use <code>@In Movie</code> to inject the movie resource.</p>

<example title="MyServlet.java">
import javax.webbeans.In;

public class MyServlet extends GenericServlet {
  @In Movie _movie;

  ...
}
</example>

<p>Most application components will use the <code>@Component</code>
discovery mechanism.  Except for the <code>META-INF/web-beans.xml</code>
marker file, no additional housekeeping code or XML is
required.  As described below, applications can reduce the configuration
by one more step with the <code>@New</code> annotation
replacing <code>@In</code>.  The target class of the <code>@New</code>
annotation is automatically registered with WebBeans even if the class
has no <code>@Component</code> annotation or if the
<code>META-INF/web-beans.xml</code> is missing.  In other words, any plain
Java class can become a part of the WebBeans system without overhead.</p>

</s2>

<s2 title="Scopes: @Singleton, @Dependent, @RequestScoped">

<p>The scope of the component determines when Resin will create a new
component and when it will reuse an old one.  Singletons will always
return the same object, while dependent components will always return
a new object instance.  Long-lived services will typically be singletons,
while scratch-space modules will be dependent components.</p>

<p>Components default to <code>@Dependent</code> scope.  Since many
components will be used as pieces of other components,
<code>@Dependent</code> is the least-surprising value as a default.</p>

<p>You can specify a component's scope with an annotation or in
the <code>&lt;bean></code> or <code>&lt;component></code> tag.  The
predefined scope values are: <code>@Dependent</code>,
<code>@RequestScoped</code>, <code>@ConversationScoped</code>,
<code>@SessionScoped</code>, <code>@ApplicationScoped</code> and
<code>@Singleton</code>.</p>

<ul>
<li><code>@Dependent</code> creates a new instance each time.</li>
<li><code>@RequestScoped</code> creates a new instance for each
servlet request, reusing the instance for the same request.</li>
<li><code>@ConversationScoped</code> creates a new instance for each
JSF conversation, i.e. for each JSF view page.</li>
<li><code>@SessionScoped</code> creates a new instance for each
HTTP session, reusing the instance for the same session.</li>
<li><code>@ApplicationScoped</code> uses a single instance in each
web-app.  For web applications, this will have the same lifecycle as
<code>@Singleton</code>.</li>
<li><code>@Singleton</code> uses a single instance in the
container.  For web applications, this will have the same lifecycle as
<code>@ApplicationScoped</code>.</li>
</ul>

<p>An example scoped resource might be a <code>Calculator</code> object which
is used only for a single instance.  It might fill the arguments while
processing a form and then calculate the result.  The
<code>@RequestScoped</code> makes sure scripts receive the same instance
each time it's called.</p>

<example title="@RequestScoped Calculator">
import javax.webbeans.RequestScoped;
import javax.webbeans.Component;

@RequestScoped
@Component
public class Calculator {
  private int _a;
  private int _b;

  public void setA(int a) { _a = a; }
  public void setB(int b) { _b = b; }

  public int getSum() { return _a + _b; }
}
</example>

<p>You could also register the same calculator using XML:</p>

<example title="resin-web.xml Calculator">
&lt;web-app xmlns="http://caucho.com/ns/resin">

  &lt;component class="example.Calculator" scope="request"/>

&lt;/web-app>
</example>

</s2>

<s2 title="@New Component Discovery">

<p>The <code>@New</code> annotation automatically registers the target
class with the WebBeans registry and tells Resin to create a new instance
of the bean, even if the bean has a singleton scope definition.
Since <code>@New</code> replaces <code>@In</code>, it can be used anywhere
<code>@In</code> can be used.</p>

<example title="MyServlet.java">
import javax.webbeans.New;

public class MyServlet extends GenericServlet {
  @New Movie _movie;

  ...
}
</example>

<p>The <code>Movie</code> is identical to the movie class defined
above, but doesn't need the <code>@Component</code> annotation and
doesn't need the <code>META-INF/web-beans.xml</code> marker file.
In many cases, the <code>@New</code> annotation can replace the Java
<code>new</code> operator.  If your application starts
using <code>@New</code> consistently, it can add injection capabilities to
a growing share of your code, letting you simplify and refactor incrementally.
</p>

<example title="Movie.java">
public class Movie {
  private String _title;

  public String getTitle() { return _title; }
  public void setTitle(String title) { _title = title; }

  @PostConstruct
  public void init() { ... }
}
</example>

</s2>

<s2 title="XML configuration overview">

<p>You can register your components and services with Resin using the
resin.conf or resin-web.xml files.  Since the WebBeans registry is integrated
with Resin, your services be treated as first-class components along with
the Resin resources.  Although most components will not need XML, there
are a few advantages for the small number of services which do use XML.</p>

<p>The XML-configuration lets you customize your application for a
particular environment, e.g. setting configuration parameters.  For example,
Resin's <code>&lt;database></code> needs to select a database driver and
configure the URL, user and password of the database as well as configuring
connection pooling parameters.  Some application services will also need
configuration.</p>

<p>In addition, the XML-configuration documents the services
you've enabled.  For heavyweight services, this documentation is critical,
while lightweight components do not need this extra housekeeping overhead.</p>

</s2>

<s2 title="bean and component registration">

<p>The <code>&lt;bean></code> and <code>&lt;component></code> tags register
application classes with Resin.  The two tags are identical except for the
expected lifecycle: <code>&lt;bean></code> configures singleton services while
<code>&lt;component></code> configures component template classes.
In other words, the default scope of a <code>&lt;bean></code>
is <code>@Singleton</code> while the default scope
of a <code>&lt;component></code> is <code>@Dependent</code>.
A <code>&lt;component></code> will create a new instance each time it's
injected or referenced, while a <code>&lt;bean></code> always returns
the same singleton instance.</p>

<example title="bean and component resin-web.xml">
&lt;web-app xmlns="http://caucho.com/ns/resin">

  &lt;bean class="example.MyService"/>

  &lt;component class="example.MyService"/>

&lt;/web-app>
</example>

<p>The <code>&lt;bean></code> and <code>&lt;component></code> tags have a
number of optional attributes:</p>

<deftable title="bean and component attributes">
<tr>
  <td>binding</td>
  <td>the <code>@BindingType</code> annotations for custom bean matching</td>
</tr>
<tr>
  <td>class</td>
  <td>the Java class of the bean or component (required)</td>
</tr>
<tr>
  <td>init</td>
  <td>optional configuration/initialization block, using bean-style assignment</td>
</tr>
<tr>
  <td>name</td>
  <td>the instance name, used for <code>@Named</code> and script integration</td>
</tr>
<tr>
  <td>scope</td>
  <td>specifies scope of the instances: request, conversation, session, application, or singleton</td>
</tr>
</deftable>

</s2>

<s2 title="bean custom XML configuration">

<p>Resin's XML configuration uses the standard JavaBeans patterns to
configure properties.  Resin uses the same mechanism for all of its own
configuration parsing, including every JavaEE configuration file, the
resin-web.xml and the resin.conf itself.  So your application will have
all the configuration flexibility it needs.</p>

<p>Since the component beans can use WebBeans
injections, injected components are typically not configured in
the resin-web.conf, avoiding the need for tags like <code>&lt;ref></code>.</p>

<example title="Hello.java">
public class Hello {
  private String _greeting = "default";

  public void setGreeting(String greeting) { _greeting = greeting; }
  public String getGreeting() { return _greeting; }
}
</example>

<p>The basic example sets a <code>greeting</code> property of a hello, world
bean.  In this example, we're configuring a singleton, but the
<code>&lt;init></code> works for dependent components as well.  Resin will
apply the configuration to the instance as part of the creation process.</p>

<example title="resin-web.xml configuring a singleton">
&lt;web-app xmlns="http://caucho.com/ns/resin">

  &lt;bean class="example.Hello">
    &lt;init>
      &lt;greeting>Hello, World&lt;/greeting>
    &lt;/init>
  &lt;/bean>

&lt;/web-app>
</example>

<p>Resin's configuration uses 5 basic bean patterns, extending the JavaBeans
conventions.  It can configure literal values like string and integers as
well as configuring other beans.  Any component bean configured by Resin
has full access to <code>@In</code> injection as well as
the standard <code>@PostConstruct</code> annotations.  Sub-beans are
not automatically registered with WebBeans, i.e. they act like the
servlet configuration.</p>

<p>(Currently the patterns are name-based like JavaBeans, since Resin
was designed before annotations.  We may add configuration annotations
in the future.</p>

<example title="Bean configuration patterns">
  public void setFoo(String data);

  public void setFoo(Movie data);

  public void addFoo(Movie data);

  public Movie createFoo();

  public void setText(String data);
</example>

<ol>
<li><code>setFoo(String)</code> configures a standard JavaBeans-style
literal.</li>
<li><code>setFoo(Movie)</code> creates a new instance of <code>Movie</code> and recursively configures it.</li>
<li><code>addFoo(Movie)</code> also creates a new instance of <code>Movie</code> and recursively configures it.  <code>addFoo</code> is an easy way of
configuring lists.</li>
<li><code>Movie createFoo()</code> lets the bean create
the <code>Movie</code> instance.  Many beans can
use <code>createFoo</code> with inner classes to
handle complex configuration.</li>
<li><code>setText</code> is called with the text contents of
the XML.  Value-style beans will use this.  (somewhat rare).</li>
</ol>

<p>As mentioned above, Resin uses these 5 patterns to handle all of the
JavaEE configuration files.  In particular, the <code>createFoo</code>
pattern returning inner classes is very handy for some complicated
configuration cases, and for cases where a sub-tag needs information about
the parent.</p>

<example title="sub-bean configuration example">
&lt;web-app xmlns="http://caucho.com/ns/resin">

  &lt;bean class="example.Theater">
    &lt;init>
      &lt;name>Balboa&lt;/name>

      &lt;movie title="The Princess Bride"/>

      &lt;movie title="The Maltese Falcon"/>
    &lt;/init>
  &lt;/bean>

&lt;/web-app>
</example>

<p>In this example, the <code>Theater</code> classes uses
an inner <code>Movie</code> class to illustrate the use of
the <code>create</code> pattern.</p>

<example title="Theater.java">
public class Theater {
  String _name;

  ArrayList&lt;Movie> _movies = new ArrayList&lt;Movie>();

  public void setName(String name) { _name = name; }

  public Movie createMovie()
  {
    return new Movie(this);
  }

  public void addMovie(Movie movie)
  {
    _movies.add(movie);
  }

  public static class Movie {
    private Theater _theater;
    private String _title;

    Movie(Theater theater)
    {
      _theater = theater;
    }

    public void setTitle(String title) { _title = title; }
  }
}
</example>

</s2>

<s2 title="Lifecycle: @PostConstruct and @PreDestroy">

<p>If your service needs to initialize itself after being configured, it
can annotation an initialization method with <code>@PostConstruct</code>.
After Resin creates, injects, and configures your component, it will call any
<code>@PostConstruct</code> methods.   Long-lived services or services that
need to register themselves with other services will typically need to
use the <code>@PostConstruct</code> annotation.</p>

<p>At the end of a component's lifetime, you might need to close some
resources, e.g. closing a socket or delisting from a timer service.  Resin
will call any component method marked with <code>@PreDestroy</code>
before it destroys the method.</p>

<p>For example, a <code>TimerService</code> may want to schedule a event
every 2 seconds.  The <code>@PostConstruct</code> method will start the timer
and the <code>@PreDestroy</code> method will stop the timer.</p>

<example title="Timer Service">
import javax.annotation.PostConstruct;
import javax.webbeans.In;
import javax.webbeans.Component;
import java.util.concurrent.ScheduledExecutorService;
import com.caucho.webbeans.Singleton;

@Component
@Singleton
public class TimerService {
  @In ScheduledExecutorService _timer;

  @PostConstruct
  public void init()
  {
    _timerFuture = _timer.scheduleAtFixedRate(this, 0, 2, TimeUnit.SECONDS);
  }

  ...

  @PreDestroy
  public void close()
  {
    _timerFuture.cancel(false);
  }
}
</example>

</s2>

</s1>

</body>
</document>
