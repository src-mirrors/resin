<document>
  <header>
    <product>resin</product>
    <title>Server Caching</title>
    <description>
      <p>Server caching can speed dynamic pages to
        near-static speeds.   Many pages created by database
        queries only change every 15 minutes or so, e.g. CNN or Wikipedia
        or Slashdot.
        Resin can cache the results and serve them like static pages.
        Resin's caching will work for any servlet, including JSP
        and XTP pages.  It depends only on the headers the servlet returns in
        the response.</p>

      <p>By default, pages are not cached.  To cache, a page must set a
        HTTP caching header.  Resin's caching operates like a proxy cache.
        It's controlled by the same HTTP headers as any proxy cache.
        Every user shares the same cached page.</p>
    </description>
  </header>

  <body>
    <localtoc/>

<s1 title="Overview">

<p>For many applications, enabling the proxy cache is one of the most
effective way of improving your application's performance.  In some
cases the difference is dramatic.  When <a href="quercus.xtp">Quercus</a>
runs Mediawiki with caching enabled, Resin can return results as fast
as static pages.  When caching is disabled, the performance is dramatically
slower.</p>

<deftable title="Mediawiki Performance">
<tr>
  <th>Cache Performance</th>
  <th>Non-Cache Performance</th>
</tr>
<tr>
  <td>4316 requests/sec</td>
  <td>29.80 requests/sec</td>
</tr>
</deftable>

</s1>

<s1 title="HTTP Caching Headers">

<deftable title="HTTP Server to Client Headers">
<tr>
  <th width='40%'>Header</th>
  <th>Description</th>
</tr>
<tr>
  <td>Cache-Control: private</td>
  <td>Restricts caching to the browser only, forbidding proxy-caching.</td>
</tr>
<tr>
  <td>Cache-Control: max-age=<em>n</em></td>
  <td>Specifies a static cache time in seconds for both the browser
and proxy cache.</td>
</tr>
<tr>
  <td>Cache-Control: s-max-age=<em>n</em></td>
  <td>Specifies a static cache time in seconds for the proxy cache only.</td>
</tr>
<tr>
  <td>Cache-Control: no-cache</td>
  <td>Disables caching entirely.</td>
</tr>
<tr>
  <td>ETag: <em>hash or identifier</em></td>
  <td>Unique identifier for the page's version.  Hash-based values are
better than date/versioning, especially in clustered configurations.</td>
</tr>
<tr>
  <td>Last-Modified: <em>time of modification</em></td>
  <td>Accepted by Resin's cache, but not recommended in clustered
configurations.</td>
</tr>
<tr>
  <td>Vary: <em>header-name</em></td>
  <td>Caches the client's header, e.g. Cookie, or Accept-encoding</td>
</tr>
</deftable>

<deftable title="HTTP Client to Server Headers">
<tr>
  <th>Header</th>
  <th>Description</th>
</tr>
<tr>
  <td>If-None-Match</td>
  <td>Specifies the ETag value for the page</td>
</tr>
<tr>
  <td>If-Modified-Since</td>
  <td>Specifies the Last-Modified value for the page</td>
</tr>
</deftable>


<s2 title="Cache-Control: max-age">

<p>Setting the <var>max-age</var> header will cache the results
for a specified time.  For heavily loaded pages, even setting short
expires times can significantly improve performance.
Pages using sessions should set a "Vary: Cookie" header, so 
anonymous users will see the cached page, while logged-in users
will see their private page.</p>

<example title="Example: 15s cache">
&lt;%@ page session="false" %&gt;
&lt;%! int counter; %&gt;
&lt;%
response.addHeader("Cache-Control", "max-age=15");
%&gt;
Count: &lt;%= counter++ %&gt;
</example>

<p><var>max-age</var> is useful for database generated pages which are
continuously, but slowly updated.  To cache based on something with a known
modified date, like a file, you can use <var>If-Modified</var>.</p>

</s2>

<s2 title="Expires">

<p>Although max-age tends to be easier and more flexible, an application
can also set the <var>Expires</var> header to enable caching, when the
expiration date is a specific time instead of an interval.
For heavily loaded pages, even setting short
expires times can significantly improve performance.  Sessions should
be disabled for caching.</p>

<p>The following example sets expiration for 15 seconds.  So the
counter should update slowly.</p>

<example title="Example: expires">
&lt;%@ page session="false" %&gt;
&lt;%! int counter; %&gt;
&lt;%
long now = System.currentTimeMillis();
response.setDateHeader("Expires", now + 15000);
%&gt;
Count: &lt;%= counter++ %&gt;
</example>

<p><var>Expires</var> is useful for database generated pages which are
continuously, but slowly updated.  To cache based on something with a known
modified date, like a file, you can use <var>If-Modified</var>.</p>

</s2>

<s2 title="ETag and If-None-Match">

<p>The <var>ETag</var> header specifies a hash or digest code for the
generated page to further improve caching.  The browser or cache
will send the <var>ETag</var> as a <var>If-None-Match</var> value when it
checks for any page updates.  If the page is the same, the application will
return a 304 NOT_MODIFIED response with an empty body.  Resin's FileServlet
automatically provides this capability for static pages.  In general, the
ETag is the most effective caching technique, although it requires a bit
more work than <var>max-age</var>.</p>

<p>The calculated <var>ETag</var> should be a hash of the result value,
not a timestamp or version, to handle clustered values in a load-balanced
configuration properly.  Since each server behind a load balancer will
have a different timestamp for the files, each server would produce
a different tag, even though the generated file was identical.  So either
producing a hash or ensuring the <var>ETag</var> value is the same is
critical.</p>

<p>When using <var>ETag</var>, your application will need to look for the
<var>If-None-Match</var> header on incoming requests.  If the value is the
same, your servlet can return 304 NOT-MODIFIED.  If the value differs,
you'll return the new content and hash.</p>

<example title="Example: ETag servlet">
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class MyServlet extends HttpServlet
{
  public void doGet(HttpServletRequest req, HttpServletResponse res)
  {
    String etag = getCurrentEtag();

    String ifNoneMatch = req.getHeader("If-None-Match");

    if (ifNoneMatch != null &amp;&amp; ifNoneMatch.equals(_etag)) {
      res.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
      return;
    }

    res.setHeader("ETag", etag);

    ... // generate response
  }
}
</example>

</s2>

<s2 title="If-Modified-Since">

<p>The <var>If-Modified-Since</var> headers let you cache based on an
underlying change date.  For example, the page may only change when an
underlying source page changes.  Resin lets you easily use 
<var>If-Modified</var> by overriding methods in HttpServlet or
in a JSP page.</p>

<p>Because of the clustering issues mentioned in the ETag section, it's
generally recommended to use ETag and If-None-Match rather than
If-Modified-Since.  In a load balanced environment, each backend server
would generally have a different Last-Modified value, while would effectively
disable caching for a proxy cache or a browser that switched from one
backend server to another.</p>

<p>The following page only changes when the underlying 'test.xml'
page changes.</p>

<example>
&lt;%@ page session="false" %&gt;
&lt;%!
int counter;

public long getLastModified(HttpServletRequest req)
{
  String path = req.getRealPath("test.xml");
  return new File(path).lastModified();
}
%&gt;
Count: &lt;%= counter++ %&gt;
</example>

<p><var>If-Modified</var> pages are useful in combination with the
<var>cache-mapping</var> configuration.</p>

</s2>

<s2 title="Vary">

<p>In some cases, you'll want to have separate cached pages for the same URL
depending on the capabilities of the browser.  Using gzip compression is
the most important example.  Browsers which can understand
gzip-compressed files receive the compressed page while simple browsers
will see the uncompressed page.  Using the "Vary" header, Resin can
cache different versions of that page.</p>

<example title="Example: vary caching for on gzip">
&lt;%
  response.addHeader("Cache-Control", "max-age=3600");
  response.addHeader("Vary", "Accept-Encoding");
%&gt;

Accept-Encoding: &lt;%= request.getHeader("Accept-Encoding") %&gt;
</example>

<p>The "Vary" header can be particularly useful for caching anonymous
pages, i.e. using "Vary: Cookie".  Logged-in users will get their custom
pages, while anonymous users will see the cached page.</p>

</s2>

</s1>

<s1 title="Included Pages">

<p>Resin can cache subpages even when the top page can't be cached.
Sites allowing user personalization will often design pages with
<var>jsp:include</var> subpages.  Some subpages are user-specific and can't
be cached.  Others are common to everybody and can be cached.</p>

<p>Resin treats subpages as independent requests, so they can be
cached independent of the top-level page.  Try the following, use the
first <var>expires</var> counter example as the included page.  Create a
top-level page that looks like:</p>

<example>
&lt;% if (! session.isNew()) { %&gt;
&lt;h1&gt;Welcome back!&lt;/h1&gt;
&lt;% } %&gt;

&lt;jsp:include page="expires.jsp"/&gt;
</example>

</s1>

<s1 title="Caching Anonymous Users">

<p>The Vary header can be used to implement anonymous user caching.  If a user
is not logged in, he will get a cached page.  If he's logged in, he'll
get his own page.  This feature will not work if anonymous users are
assigned cookies for tracking purposes.</p>

<p>To make anonymous caching work, you must set the <var>Vary: Cookie</var>
If you omit the Vary header, Resin will use
the <var>max-age</var> to cache the same page for every user.</p>

<example>
&lt;%@ page session="false" %&gt;
&lt;%! int _counter; %&gt;
&lt;%
response.addHeader("Cache-Control", "max-age=15");
response.addHeader("Vary", "Cookie");

String user = request.getParameter("user");
%&gt;
User: &lt;%= user %&gt; &lt;%= counter++ %&gt;
</example>

<p>The top page must still set the <var>max-age</var> or
<var>If-Modified</var> header, but Resin will take care of deciding if the
page is cacheable or not.  If the request has any cookies, Resin will
not cache it and will not use the cached page.
If it has no cookies, Resin will use the cached page.</p>

<p>When using Vary: Cookie, user tracking cookies will make the
page uncacheable even if the page is the same for all users.
Resin chooses to cache or not based on the existence of any cookies
in the request, whether they're used or not.</p>

</s1>

<s1 title="cache-mapping">

<p><var>cache-mapping</var> assigns a <var>max-age</var>
and <var>Expires</var> to a cacheable page, i.e. a page with an <var>ETag</var>
or <var>Last-Modified</var> setting.  It does not affect <var>max-age</var> or
<var>Expires</var> cached pages.  The FileServlet takes
advantage of <var>cache-mapping</var> because it provides the
ETag servlet.</p>

<p>Often, you want a long Expires time for a page to a browser.  For
example, any gif will not change for 24 hours.  That keeps browsers
from asking for the same gif every five seconds; that's especially
important for tiny formatting gifs.  However, as soon as that page or
gif changes, you want the change immediately available to any new
browser or to a browser using reload.</p>

<p>Here's how you would set the Expires to 24 hours for a gif, based
on the default FileServlet.</p>

<example title="Example: caching .gif files for 24h">
&lt;web-app xmlns="http://caucho.com/ns/resin">

  &lt;cache-mapping url-pattern='*.gif'
                 expires='24h'/&gt;
&lt;/web-app&gt;
</example>

<p>The <var>cache-mapping</var> automatically generates the Expires
header.  It only works for cacheable pages setting If-Modified or
ETag.  It will not affect pages explicily setting Expires or
non-cacheable pages.  So it's safe to create a cache-mapping
for <var>*.jsp</var> even if only some are cacheable.</p>

</s1>

<s1 title="Debugging caching">

<p>When designing and testing your cached page, it's important to see
how Resin is caching the page.  To turn on logging for caching, you'll
add the following to your resin.conf:</p>

<example title="Example: adding caching log">
&lt;resin xmlns="http://caucho.com/ns/resin">

  &lt;logger name="com.caucho.server.cache" level="fine"/>

  ...

&lt;/resin>
</example>

<p>The output will look something like the following:</p>

<results>
[10:18:11.369] caching: /images/caucho-white.jpg etag="AAAAPbkEyoA" length=6190
[10:18:11.377] caching: /images/logo.gif etag="AAAAOQ9zLeQ" length=571
[10:18:11.393] caching: /css/default.css etag="AAAANzMooDY" length=1665
[10:18:11.524] caching: /images/pixel.gif etag="AAAANpcE4pY" length=61

...

[2003/09/12 10:18:49.303] using cache: /css/default.css
[2003/09/12 10:18:49.346] using cache: /images/pixel.gif
[2003/09/12 10:18:49.348] using cache: /images/caucho-white.jpg
[2003/09/12 10:18:49.362] using cache: /images/logo.gif
</results>

</s1>
  </body>
</document>