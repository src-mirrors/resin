<document>
<header>
  <title>@Entity Table Configuration</title>
  <version>Resin 3.0</version>

  <description>
  <p>Describes the basic annotation for a single-table entity bean.</p>

  </description>
</header>

<body>
<summary objsummary="localtoc"/>

<s1 title="See Also">

<ul>
<li>See <a href="http://wiki.caucho.com/Amber">http://wiki.caucho.com/Amber</a> the Amber wiki.
</li><li>See <a href="../examples/amber-basic/index.xtp">Basic tutorial</a> for
a complete single-table example.
</li><li>See <a href="../examples/amber-many2one/index.xtp">Many-to-one tutorial</a> for
basic relations.
</li></ul>

</s1>

<s1 title="Table annotations">

<s2 title="@Entity" type="defun">

<p>Annotates the class as an entity bean.</p>

<p>See the <a href="../examples/amber-basic/index.xtp">basic property tutorial</a>
and the <a href="../examples/amber-basic-field/index.xtp">basic field tutorial</a>
for an introduction.</p>

<deftable-childtags>
<tr>
  <td>name</td>
  <td>The name of the bean</td><td>The class name (unqualified)</td>
</tr>
</deftable-childtags>

<p>The fields or properties will be annotated by @Id, @Basic, etc.
Amber will detect either field or property annotation by the
type for the @Id.  In other words, if Amber sees an @Id on a field,
it will use field access.  If Amber sees @Id on a method, it will use
property access.</p>

<def>
package javax.persistence;

@Target(TYPE)
@Retention(RUNTIME)
public @interface Entity {
  String name() default "";
}
</def>

</s2>

<s2 title="@SecondaryTable" type="defun">

<p>Specifies a secondary database table for an entity bean.
The secondary table will contain the fields with a secondaryTable
in the @Column.</p>

<deftable-childtags>
<tr>
  <td>name</td>
  <td>The name of the table</td><td>The unqualified class name.</td>
</tr>
<tr>
  <td>catalog</td>
  <td>the table's catalog</td>
  <td>none</td>
</tr>
<tr>
  <td>schema</td>
  <td>the table's schema</td><td>none</td>
</tr>
<tr>
  <td>pkJoinColumns</td>
  <td>join column to the primary table</td>
  <td>joins the primary key</td>
</tr>
<tr>
  <td>uniqueConstraint</td>
  <td>unique constraints during generation</td>
  <td>none</td>
</tr>
</deftable-childtags>

<def>
package javax.persistence;

@Target(TYPE)
@Retention(RUNTIME)
public @interface SecondaryTable {
  String name() default "";
  String catalog() default "";
  String schema() default "";
  PrimaryKeyJoinColumn []pkJoinColumns() default {};
  UniqueConstraint []uniqueConstraints() default {};
}
</def>

</s2>

<s2 title="@Table" type="defun">

<p>Specifies the database table for an entity bean.  The
default table name is the class name.</p>

<deftable-childtags>
<tr><td>name</td><td>The name of the table</td><td>The unqualified class name.
</td></tr><tr><td>catalog</td><td>the table's catalog</td><td>none
</td></tr><tr><td>schema</td><td>the table's schema</td><td>none
</td></tr><tr><td>uniqueConstraint</td><td>unique constraints during generation</td><td>none
</td></tr></deftable-childtags>

<def>
package javax.persistence;

@Target(TYPE)
@Retention(RUNTIME)
public @interface Table {
  String name() default "";
  String catalog() default "";
  String schema() default "";
  UniqueConstraint []uniqueConstraints() default {};
}
</def>

</s2>

</s1>

<s1 title="Property Annotations">

<s2 title="@Basic" type="defun">

<p>Marks a field as a persistent field.</p>

<deftable-childtags>
<tr><td>fetch</td><td>EAGER or LAZY fetching</td><td>FetchType.EAGER
</td></tr><tr><td>optional</td><td>if true, the column may be null</td><td>true
</td></tr></deftable-childtags>

<p>The fetch types are:
</p><ul>
<li>EAGER - fetch the field when the bean is loaded
</li><li>LAZY - fetch the field only when the field is used
</li></ul>

<example title="String property ">
@Entity
public class Course {
  @Basic
  public String getName()

  ...
}
</example>

<example title="Lazy-loaded property ">
@Entity
public class Course {
  @Basic(fetch=FetchType.LAZY)
  public String getMassiveText()

  ...
}
</example>

<def title="javax.persistence.Basic">
package javax.persistence;

@Target({Method, FIELD})
@Retention(RUNTIME)
public @interface Basic {
  FetchType fetch() default EAGER;
  boolean optional() default true;
}
</def>

</s2>

<s2 title="@Column" type="defun">

<p>Specifies the field's SQL column name as well as any CREATE TABLE
properties for auto generation.</p>

<deftable-childtags>
<tr><td>name</td><td>The SQL name of the column</td><td>the field name
</td></tr><tr><td>unique</td><td>True for UNIQUE columns</td><td>false
</td></tr><tr><td>nullable</td><td>False for IS NOT NULL columns</td><td>true
</td></tr><tr><td>insertable</td><td>True if column is inserted on a <code>create</code> call</td><td>true
</td></tr><tr><td>updatable</td><td>True if column is updated when the field is modified</td><td>false
</td></tr><tr><td>columnDefinition</td><td>SQL to create the column in a CREATE TABLE</td><td>none
</td></tr><tr><td>table</td><td>specified if column is stored in a secondary table</td><td>none
</td></tr><tr><td>length</td><td>the default length for a VARCHAR for a CREATE TABLE</td><td>255
</td></tr><tr><td>precision</td><td>the default length for a number definition for a CREATE TABLE</td><td>0
</td></tr><tr><td>scale</td><td>the default length for a number definition for a CREATE TABLE</td><td>0
</td></tr></deftable-childtags>

<example title="String property ">
@Entity
public class Course {
  @Basic
  @Column(unique=true,
          nullable=false,
          length=32)
  public String getName()

  ...
}
</example>

<def title="javax.persistence.Column">
@Target({Method, FIELD})
@Retention(RUNTIME)
public @interface Column {
  String name() default "";
  boolean unique() default false;
  boolean nullable() default true;
  boolean insertable() default true;
  boolean updateable() default true;
  String columnDefinition() default "";
  String table() default "";
  int length() default 255;
  int precision() default 0;
  int scale() default 0;
  boolean specified() default true;
}
</def>

</s2>

</s1>

<s1 title="Primary Key Annotations">

<s2 title="@Id" type="defun">

<p>Marks a field as a primary key.  The <code>@Id</code>
may be used in combination with <code>@GeneratedValue</code> to specify a generator for automatic key generation when new
objects are created.</p>

<p>The default column name is "ID".</p>

<example title="automatic generation">
import javax.persistence.*;

@Entity
public class Course {
  @Id
  @Column(name="t_id")
  @GeneratedValue
  public long getId()

  ...
}
</example>

<def title="javax.persistence.Id">
@Target({METHOD, FIELD})
@Retention(RUNTIME)
public @interface Id {
}
</def>

</s2>

<s2 title="@GeneratedValue" type="defun">

<p>Used with @Id to specify a generator for automatic key generation when new
objects are created.</p>

<deftable-childtags>
<tr><td>strategy</td><td>The auto-generation type</td><td>AUTO
</td></tr><tr><td>generator</td><td>The sequence or table generator name</td><td>\${table}_cseq
</td></tr></deftable-childtags>

<p>The generator types are:
</p><ul>
<li>IDENTITY - the database supplies the new key, e.g. auto_increment, SERIAL, or IDENTITY
</li><li>SEQUENCE - use a SEQUENCE type to generate the key
</li><li>TABLE - use a @TableGenerator for the key
</li><li>AUTO - choose the generator based on the database
<ul>
<li>MySQL - IDENTITY using auto_increment
</li><li>Resin - IDENTITY using auto_increment
</li><li>Postgres - SEQUENCE
</li><li>Oracle - SEQUENCE
</li></ul>
</li></ul>

<p>For SEQUENCE and TABLE, Resin will create the sequence
name as "\${table}_cseq".</p>

<example title="automatic generation">
import javax.persistence.*;

@Entity
public class Course {
  @Id
  @GeneratedValue
  public long getId()

  ...
}
</example>

<example title="sequence generation">
import javax.persistence.*;

@Entity
public class Course {
  @Id
  @GeneratedValue(strategy=GeneratorType.AUTO
                  generator="COURSE_SEQ")
  public long getId()

  ...
}
</example>

<def title="javax.persistence.GeneratedValue">
@Target({METHOD, FIELD})
@Retention(RUNTIME)
public @interface GeneratedValue {
  GenerationType strategy() default AUTO;
  String generator() default "";
}
</def>

</s2>

</s1>

<s1 title="Relation annotations">

<s2 title="@JoinTable" type="defun">

<p>Defines an association table for a many-to-many relation.</p>

<deftable-childtags>
<tr><td>name</td><td>Table definition for the association table</td><td>concatening the source and target table names
</td></tr><tr><td>catalog</td><td>Database catalog</td><td>""
</td></tr><tr><td>schema</td><td>Database schema</td><td>""
</td></tr><tr><td>joinColumns</td><td>Columns from from the association table to the source table</td><td>Uses the source table primary key
</td></tr><tr><td>inverseJoinColumns</td><td>Columns from from the association table to the target table</td><td>Uses the target table primary key
</td></tr></deftable-childtags>

<def title="javax.persistence.JoinTable">
@Target({METHOD, FIELD})
@Retention(RUNTIME)
public @interface JoinTable {
  String table() default "";
  String catalog() default "";
  String schema() default "";
  JoinColumn []joinColumns() default {};
  JoinColumn []inverseJoinColumns() default {};
  UniqueContraint []uniqueConstraint() default {};
}
</def>

</s2>

<s2 title="@JoinColumn" type="defun">

<p>Defines a join (foreign) columns.  Used for <a href="#@ManyToOne">@ManyToOne</a>.</p>

<p>See also <a href="#@Column">@Column</a> for
corresponding definition for <a href="#@Basic">@Basic</a> columns.</p>

<p>See the <a href="../examples/amber-many2one/index.xtp">Many-to-One
tutorial</a> for a full example.</p>

<deftable-childtags>
<tr><td>name</td><td>The column name of the source table</td><td>the column name of the target key
</td></tr><tr><td>referencedColumnName</td><td>The target column for composite keys</td><td>the single primary key
</td></tr><tr><td>unique</td><td>True if unique</td><td>false
</td></tr><tr><td>nullable</td><td>False if IS NOT NULL</td><td>true
</td></tr><tr><td>insertable</td><td>True if the column is inserted on a <code>create</code></td><td>true
</td></tr><tr><td>updateable</td><td>True if the column is updated on field changes</td><td>true
</td></tr><tr><td>columnDefinition</td><td>SQL column definition</td><td>false
</td></tr><tr><td>table</td><td>specifies a secondary table if not in the primary</td><td>none
</td></tr></deftable-childtags>

<example title="Student to House link">
public class Student {
  @Id
  @Column(name="student_id")
  long getId()

  @ManyToOne
  @JoinColumn(name="house_id")
  public House getHouse()
}
</example>

<example title="Student SQL">
CREATE TABLE Student {
  student_id BIGINT PRIMARY KEY auto_increment

  house_id BIGINT REFERENCES House(id)
)
</example>

<def title="javax.persistence.JoinColumn">
@Target({TYPE, METHOD, FIELD})
@Retention(RUNTIME)
public @interface JoinColumn {
  String name() default "";
  String referencedColumnName() default "";
  boolean unique() default false;
  boolean nullable() default false;
  boolean insertable() default true;
  boolean updateable() default true;
  String columnDefinition() default "";
  String table() default "";
}
</def>

</s2>

<s2 title="@JoinColumns" type="defun">

<p>Defines a set of join (foreign) columns for composite keys.</p>

<def title="javax.persistence.ManyToOne">
@Target({TYPE,METHOD, FIELD})
@Retention(RUNTIME)
public @interface JoinColumns {
  JoinColumn [] value() default{}
}
</def>

</s2>

<s2 title="@ManyToMany" type="defun">

<p>Marks a field as a many-to-many (association) relation.</p>

<p>The column names are the key columns of the source and target tables.</p>

<p>See the <a href="../examples/amber-many2many/index.xtp">many-to-many tutorial</a> for an example.</p>

<deftable-childtags>
<tr><td>targetEntity</td><td>The class of the target entity</td><td>the property's type
</td></tr><tr><td>cascade</td><td>Operations which cascade to the target</td><td>none
</td></tr><tr><td>fetch</td><td>EAGER or LAZY fetching</td><td>FetchType.EAGER
</td></tr><tr><td>mappedBy</td><td>Specifies the source relation if a target</td><td>
</td></tr></deftable-childtags>

<example title="Simple link ">
@Entity
public class Student {
  @ManyToMany
  @JoinTable(
    name="student_course_map",
    joinColumns={@JoinColumn(name="student_id")},
    inverseJoinColumns={@JoinColumn(name="course_id")}
  )
  public Collection getCourses()

  ...
}
</example>

<def title="javax.persistence.ManyToMany">
@Target({METHOD, FIELD})
@Retention(RUNTIME)
public @interface ManyToMany {
  String targetEntity default "";
  CascadeType []cascade() default {};
  FetchType fetch() default LAZY;
  String mappedBy isInverse() default "";
}
</def>

</s2>

<s2 title="@ManyToOne" type="defun">

<p>Marks a field as a many-to-one (link) relation.</p>

<p>The default column name is the column name of the target key.</p>

<p>See the <a href="../examples/amber-many2one/index.xtp">many-to-one tutorial</a> for an example.</p>

<deftable-childtags>
<tr><td>targetEntity</td><td>The class of the target entity</td><td>the property's type
</td></tr><tr><td>cascade</td><td>Operations which cascade to the target</td><td>none
</td></tr><tr><td>fetch</td><td>EAGER or LAZY fetching</td><td>FetchType.EAGER
</td></tr><tr><td>optional</td><td>If false, the relation must always have a value</td><td>true
</td></tr></deftable-childtags>

<example title="Simple link ">
@Entity
public class Student {
  @ManyToOne
  @JoinColumn(name="house")
  public House getHouse()

  ...
}
</example>

<def title="javax.persistence.ManyToOne">
@Target({Method, FIELD})
@Retention(RUNTIME)
public @interface ManyToOne {
  String targetEntity default "";
  CascadeType []cascade() default {};
  FetchType fetch() default EAGER;
  boolean optional() default true;
}
</def>

</s2>

<s2 title="@OneToMany" type="defun">

<p>Marks a field as a one-to-many (collection) relation.
Because a one-to-many field is dependent, it
needs a @ManyToOne relation on the source table which defines the column.</p>

<deftable-childtags>
<tr><td>targetEntity</td><td>The class of the target entity</td><td>the property's type
</td></tr><tr><td>cascade</td><td>Operations which cascade to the target</td><td>none
</td></tr><tr><td>fetch</td><td>EAGER or LAZY fetching</td><td>FetchType.EAGER
</td></tr><tr><td>mappedBy</td><td>Specifies the owning @ManyToOne property</td><td>
</td></tr></deftable-childtags>

<example title="Collection java">
@Entity
public class House {
  ...
  @OneToMany(targetEntity=Student.class,
             mappedBy="house")
  public Collection getStudents()
}

@Entity
public class Student {
  ...
  @ManyToOne
  @JoinColumn(name="house")
  public House getHouse()
}
</example>

<example title="Collection SQL">
CREATE TABLE House {
  id BIGINT PRIMARY KEY
)

CREATE TABLE Student {
  id BIGINT PRIMARY KEY,

  house BIGINT REFERENCES House(id)
)
</example>

<def title="javax.persistence.OneToMany">
@Target({METHOD, FIELD})
@Retention(RUNTIME)
public @interface OneToMany {
  String targetEntity default "";
  CascadeType []cascade() default {};
  FetchType fetch() default EAGER;
  String mappedBy() default "";
}
</def>

</s2>

<s2 title="@OneToOne" type="defun">

<p>Marks a field as a one-to-one (dependent link) relation.
Because a one-to-one field is dependent, it
needs a @ManyToOne relation on the source table which defines the column.</p>

<deftable-childtags>
<tr><td>targetEntity</td><td>The class of the target entity</td><td>the property's type
</td></tr><tr><td>cascade</td><td>Operations which cascade to the target</td><td>none
</td></tr><tr><td>fetch</td><td>EAGER or LAZY fetching</td><td>FetchType.EAGER
</td></tr><tr><td>mappedBy</td><td>Specifies the owning relation</td><td>
</td></tr></deftable-childtags>

<def title="javax.persistence.OneToOne">
@Target({METHOD, FIELD})
@Retention(RUNTIME)
public @interface OneToOne {
  String targetEntity default "";
  CascadeType []cascade() default {};
  FetchType fetch() default EAGER;
  boolean optional() default true;
  String mappedBy() default "";
}
</def>

</s2>

</s1>

<s1 title="Inheritance annotations">

<s2 title="@DiscriminatorColumn" type="defun">

<p>Configures the discriminator column.</p>

<def title="javax.persistence.DiscriminatorColumn">
@Target(TYPE)
@Retention(RUNTIME)
public @interface DiscriminatorColumn {
  String name() default "";
  DiscriminatorType discriminatorType() default STRING;
  String columnDefinition() default "";
  int length() default 31;
}
</def>

</s2>

<s2 title="@Inheritance" type="defun">

<p>@Inheritance marks the entity bean as supporting inheritance,
i.e. the database maps to different Java classes depending on
a discriminator value.</p>

<def title="javax.persistence.Inheritance">
@Target(TYPE)
@Retention(RUNTIME)
public @interface Inheritance {
  InteritanceType strategy() default SINGLE_TABLE;
}
</def>

</s2>

<s2 title="InheritanceType" type="defun">

<def title="javax.persistence.InheritanceType">
public enum InheritanceType {
  SINGLE_TABLE,
  JOINED,
  TABLE_PER_CLASS
}
</def>

</s2>

</s1>
</body>

</document>
