<document>
  <header>
    <product>resin</product>
    <title>Hessian 2.0 Draft Specification</title>
    <date>Jul 8, 2006</date>
    <description>
      <p>Hessian is a compact binary protocol for connecting web
      services.</p>

      <p>Because Hessian is a small protocol, J2ME devices like cell-phones can use
      it to connect to Resin servers.  Because it's powerful, it can be used
      for EJB services.</p>
    </description>
  </header>

  <body>
    <localtoc/>

<s1 title="Design Goals">

<p>Hessian 2 is a compaction of the Hessian protocol.  All
Hessian 1 codes are understood by Hessian 2.  The extended codes
provide compact formats for common values, e.g. storing an
integer zero as a single byte instead of Hessian 1's 5 bytes.</p>

<p>The <a href="http://www.caucho.com/hessian">Hessian home page</a>
contains the latest information about Hessian.</p>

<p>Unlike older binary protocols, Hessian is both self-describing
and portable across languages.  The wire protocol for web
services should be invisible to application writers.  Wire protocols
should not require external schema or IDL.</p>

<p>Given the EJB environment, the Hessian protocol has the
following requirements:</p>

<ul>
<li>It must support XML as a first class object.</li>
<li>It must not require external IDL or schema definitions; it should be
invisible to application writers.</li>
<li>It must have sufficient power to serialize Java.</li>
<li>It must have sufficient power to support EJB.</li>
<li>It must allow non-Java clients to use web services.</li>
<li>It must allow web services to deployed as a Servlet.</li>
<li>It must be simple so it can be effectively tested.</li>
<li>It must be as fast as possible.</li>
<li>It should support transaction contexts.</li>
</ul>

</s1>

<s1 title="Hessian 2.0 Grammar">

<def title="Hessian 2.0 Serialization Grammar">
        # starting production
top     ::= object

        # 8-bit binary data split into 64k chunks
binary  ::= ('b' b16 b8 binary-data)* 'B' b16 b8 binary-data
        ::= [x20-x2f] binary-data    # binary data of length 0-15

boolean ::= 'T'
        ::= 'F'

        # time in UTC encoded as 64-bit long milliseconds since epoch
date    ::= 'd' b64 b56 b48 b40 b32 b24 b16 b8

        # 64-bit IEEE double
double  ::= 'D' b64 b56 b48 b40 b32 b24 b16 b8
        ::= x67                   # 0.0
        ::= x68                   # 1.0
        ::= x69 b8                # byte cast to double (-128.0 to 127.0)
        ::= x6a b16 b8            # short cast to double (-32768.0 to 32767.0)
        ::= x6b b32 b24 b16 b8    # 32-bit int cast to double
        ::= x70 b32 b24 b16 b8    # 32-bit float cast to double

        # 32-bit signed integer
int     ::= 'I' b32 b24 b16 b8
        ::= [x80-xbf]             # -x10 to x3f
        ::= [xc0-xcf] b8          # -x800 to x7ff
        ::= [xd0-xd7] b16 b8      # -x40000 to x3ffff

        # list/vector length 
length  ::= 'l' b32 b24 b16 b8
        ::= x6e int

        # list/vector
list    ::= 'V' type? length? object* 'z'
        ::= 'v' int int object*   # type-ref, length

        # 64-bit signed long integer
long    ::= 'L' b64 b56 b48 b40 b32 b24 b16 b8
        ::= [xd8-xef]             # -x08 to x0f
        ::= [xf0-xff] b8          # -x800 to x7ff
        ::= [x38-x3f] b16 b8      # -x40000 to x3ffff
        ::= x77 b32 b24 b16 b8    # 32-bit integer cast to long

        # map/object
map     ::= 'M' type? (object object)* 'z'  # key, value map pairs
        ::= 'O' type int string*  # Object definition - length and fields
        ::= 'o' int object*       # Object instance - type-ref

null    ::= 'N'

        # main production for object serialization
object  ::= null
        ::= binary
        ::= boolean
        ::= date
        ::= double
        ::= int
        ::= list
        ::= map
        ::= long
        ::= remote
        ::= ref
        ::= string
        ::= xml

        # Object reference (e.g. circular trees and graphs)
ref     ::= 'R' b32 b24 b16 b8    # reference to nth map/list in stream
        ::= x50 b8                # reference to 1-255th map/list
        ::= x51 b16 b8            # reference to 1-65535th map/list

        # remote object using URL as locator
remote  ::= 'r' type? string

        # UTF-8 encoded character string split into 64k chunks
string  ::= ('s' b16 b8 string-data)* 'S' b16 b8 string-data
        ::= [x00-x1f] string-data    # string of length 0 to 31

        # map/list types for OO languages
type    ::= 't' b16 b8 type-string   # type name
        ::= x75 int                  # type reference

        # UTF-8 encoded XML data
xml     ::= ('x' b16 b8 xml-data)* 'X' b16 b8 xml-data
</def>

<def title="Messaging/Envelope Grammar">
top     ::= call
        ::= reply
        ::= envelope

        # RPC-style call
call    ::= 'c' x02 x00 header* method object* 'z'

        # Envelope (e.g. for security)
envelop ::= 'E' x02 x00 int (string object)* binary int (string object)*

fault   ::= 'f' (object object)* 'z'

        # message header for security/transactional context
header  ::= 'H' b16 b8 header-string object

        # RPC method name (possibly mangled for overloading)
method  ::= 'm' b16 b8 method-string

        # unidirectional message or RPC reply
reply   ::= 'r' x02 x00 header* object 'z'  # successful message/reply
        ::= 'r' x02 x00 header* fault 'z'   # exception/fault reply
</def>

</s1>

<s1 title="Serialization">

<p>Hessian's object serialization has 9 primitive types:</p>

<ol>
<li><a href="#boolean">boolean</a>
</li><li>32-bit <a href="#int">int</a>
</li><li>64-bit <a href="#long">long</a>
</li><li>64-bit <a href="#double">double</a>
</li><li>64-bit <a href="#date">date</a>
</li><li>UTF8-encoded <a href="#string">string</a>
</li><li>UTF8-encoded <a href="#xml">xml</a>
</li><li>raw <a href="#binary">binary</a> data
</li><li><a href="#remote">remote</a> objects
</li></ol>

<p>It has 2 combining constructs:</p>
<ol>
<li><a href="#list">list</a> for lists and arrays
</li><li><a href="#map">map</a> for objects and hash tables.
</li></ol>

<p>Finally, it has 2 special contructs:</p>
<ol>
<li><a href="#null">null</a> for null values
</li><li><a href="#ref">ref</a> for shared and circular object references.
</li></ol>

<s2 title="null" type="defun">
<p>Null represents a null pointer.</p>

<p>The byte <var>'N'</var> represents the null pointer.</p>

<p><var>null</var> values are allowed in place of any <var>string</var>, <var>xml</var>,
<var>binary</var>, <var>list</var>, <var>map</var>, or <var>remote</var>.</p>

<example title="null">
null ::= N
</example>
</s2>

<s2 title="boolean" type="defun">
<p>The byte <var>'F'</var> represents false and the byte <var>'T'</var>
represents true.</p>

<def>
boolean ::= T
        ::= F
</def>

<example title="boolean true">
T
</example>

</s2>

<s2 title="int" type="defun">
<p>A 32-bit signed integer.  An integer is represented by the
byte <var>'I'</var> followed by the 4-bytes of the integer in big-endian
order</p>

<def>
int ::= I b32 b24 b16 b8
</def>

<example title="integer 300">
I x00 x00 x01 x2c
</example>

<s3 title="Compact: single octet integers">

<p>Integers between -16 and 31 are represented by a single byte in the
range <code>x80</code> to <code>xaf</code>.
The value of the integer is <code>b0 - x90</code>.</p>

<def>
int ::= [x80-xaf]
</def>

<p>The integer zero is represented by <code>x90</code>,
-1 is represented by <code>x8f</code> and
17 is represented by <code>xa1</code></p>

</s3>

<s3 title="Compact: two octet integers (byte)">

<p>Integers between -2048 and 2047 are encoded in two bytes with
the leading byte in the range <code>xd0</code> to <code>xdf</code>.
The value of the integer is <code>256 * (b0 - xd8) + b1</code>.</p>

<def>
int ::= [xc0-xcf] b1
</def>

<p>The integer zero is represented by <code>xd8 x00</code>,
-256 is represented by <code>xd7 x00</code> and
513 is represented by <code>xda x01</code></p>

</s3>

<s3 title="Compact: three octet integers (short)">

<p>Integers between -262144 and 262143 are encoded in three bytes with
the leading byte in the range <code>x58</code> to <code>x5f</code>.
The value of the integer is <code>65536 * (b0 - x5c) + 256 * b1 + b0</code>.</p>

<def>
int ::= [xd0-xd7] b1 b2
</def>

<p>The integer zero is represented by <code>xd4 x00 x00</code>,
-65536 is represented by <code>xd3 x00 x00</code> and
65537 is represented by <code>xd5 x00 x01</code></p>

</s3>

</s2>

<s2 title="long" type="defun">
<p>A 64-bit signed integer.  An long is represented by the
byte <var>'L'</var> followed by the 8-bytes of the integer in big-endian order
</p>

<def>
long ::= L b64 b56 b48 b40 b32 b24 b16 b8
</def>

<example title="long 300">
L x00 x00 x00 x00 x00 x00 x01 x2c
</example>

<s3 title="Compact: single octet longs">

<p>Longs between -8 and 15 are represented by a single byte in the
range <code>xd8</code> to <code>xef</code>.
The value of the long is <code>b0 - xe0</code>.</p>

<def>
long ::= [xd8-xef]
</def>

<p>The long zero is represented by <code>xe0</code>,
-1 is represented by <code>xdf</code> and
15 is represented by <code>xef</code></p>

</s3>

<s3 title="Compact: two octet longs (byte)">

<p>Longs between -2048 and 2047 are encoded in two bytes with
the leading byte in the range <code>xf0</code> to <code>xff</code>.
The value of the long is <code>256 * (b0 - xf8) + b1</code>.</p>

<def>
long ::= [xf0-xff] b1
</def>

<p>The long zero is represented by <code>xf8 x00</code>,
-256 is represented by <code>xf7 x00</code> and
513 is represented by <code>xfa x01</code></p>

</s3>

<s3 title="Compact: three octet longs (short)">

<p>Longs between -262144 and 262143 are encoded in three bytes with
the leading byte in the range <code>x38</code> to <code>x3f</code>.
The value of the long is <code>65536 * (b0 - x3c) + 256 * b1 + b0</code>.</p>

<def>
long ::= [x38-x3f] b1 b2
</def>

<p>The long zero is represented by <code>x3c x00 x00</code>,
-65536 is represented by <code>x3b x00 x00</code> and
65537 is represented by <code>x3d x00 x01</code></p>

</s3>

</s2>

<s2 title="double" type="defun">
<p>A 64-bit IEEE floating pointer number.</p>

<def>
double ::= D b64 b56 b48 b40 b32 b24 b16 b8
</def>

<example title="double 12.25">
D x40 x28 x80 x00 x00 x00 x00 x00
</example>

</s2>

<s2 title="date" type="defun">
<p>Date represented by a 64-bits long of milliseconds since the epoch, GMT.</p>

<def>
date ::= d b64 b56 b48 b40 b32 b24 b16 b8
</def>

<example title="2:51:31 May 8, 1998 GMT">
d x00 x00 x00 xd0 x4b x92 x84 xb8
</example>

</s2>

<s2 title="string" type="defun">
<p>A 16-bit unicode character string encoded in UTF-8.
Strings are encoded in chunks.  <var>'S'</var> represents the final chunk
and <var>'s'</var> represents any initial chunk.  Each chunk has a 16-bit
length value.</p>

<p>The length is the number of characters, which may be different than
the number of bytes.</p>

<p>String chunks may not split surrogate pairs.</p>

<def>
string ::= (s b16 b8 utf-8-data)* S b16 b8 utf-8-data
</def>

<example title="&quot;Hello&quot; string">
S x00 x05 hello
</example>

<s3 title="Compact: short strings">

<p>Strings with length less than 15 may be encoded with a single
length byte [x00-x0f].</p>

<def>
string ::= [x00-x0f] string-data
</def>

<example title="&quot;Hello&quot; string">
x05 hello
</example>

</s3>

</s2>

<s2 title="xml" type="defun">
<p>An XML document encoded as a 16-bit unicode character
string encoded in UTF-8.
XML data is encoded in chunks.  <var>'X'</var> represents the final chunk
and <var>'x'</var> represents any initial chunk.</p>

<p>Each chunk has a 16-bit
length value.  The length is the number of characters, which may
be different than the number of bytes.</p>

<def>
xml ::= (x b16 b8 utf-8-data)* X b16 b8 utf-8-data
</def>

<example title="trivial XML document">
X x00 x10 &lt;top&gt;hello&lt;/top&gt;
</example>

<note>Because this document does not define the language mapping,
implementations are free to return a string when reading an <var>xml</var>
entity.</note>

</s2>

<s2 title="binary" type="defun">
<p>A binary value.</p>

<p>Binary data is encoded in chunks.  <var>'B'</var> represents the final chunk
and <var>'b'</var> represents any initial chunk.  Each chunk has a 16-bit
length value.</p>

<def>
binary ::= (b b16 b8 binary-data)* B b16 b8 binary-data
</def>

</s2>

<s2 title="list" type="defun">
<p>An ordered list, like an array.  All lists have a type string,
a length, a list of objects, and a trailing 'z'.
The type string may be an arbitrary UTF-8 string understood
by the service (often a Java class name, but this isn't required.)
The length may be -1 to indicate that the list is variable length.
</p>

<def>
list ::= V <var>type</var>? <var>length</var>? <var>object</var>* z
</def>

<p>Each <var>list</var> item is added to the reference list to handle
shared and circular elements.  See the
<var>ref</var> element.</p>

<p>Any parser expecting a <var>list</var> must also accept a <var>null</var>
or a shared <var>ref</var>.</p>

<results title="serialization of a Java int[] = {0, 1}">
V t x00 x04 [int
  l x00 x00 x00 x02
  I x00 x00 x00 x00
  I x00 x00 x00 x01
  z
</results>

<results title="anonymous variable-length list = {0, &quot;foobar&quot;}">
V I x00 x00 x00 x00
  S x00 x06 foobar
  z
</results>

<note>The valid values of <var>type</var> are not specified in this
document and may depend on the specific application.  For example, a
Java EJB server which exposes an Hessian interface can use the <var>type</var>
information to instantiate the specific array type.
On the other hand, a Perl server would likely ignore the contents of <var>type</var>
entirely and create a generic array.
</note>

<s3 title="Compact: repeated list">

<p>Hessian 2.0 allows a compact form of the list for successive lists of
the same type where the length is known beforehand.
The type and length are encoded by integers, where the type is a reference to
an earlier specified type.</p>

<pre>
list ::= 'v' <var>int (type)</var> <var>int (length)</var> <var>object</var>*
</pre>

<example title="int[] {0, 1}">
V t x00 x04 [int u x02 x90 x91 z
v x01 x02 x90 x91
</example>

</s3>

</s2>

<s2 title="map" type="defun">
<p>Represents serialized objects and Maps. The <var>type</var>
element describes the type of the map.  Objects are represented by a
map from field names to their values and <var>type</var> is the class
of the object itself.</p>

<def>
map ::= M t b16 b8 type-string (<var>object</var>, <var>object</var>)* z
</def>

<p>The <var>type</var> may be empty, i.e. a zero length.  The parser is
responsible for choosing a type if one is not specified.
For objects, unrecognized keys will be ignored.</p>

<p>Each <var>map</var> is added to the reference list.  Any time the
parser expects a <var>map</var>, it must also be able to support a
<var>null</var> or a <var>ref</var>.</p>

<example title="Serialization of a Java Object">
public class Car implements Serializable {
  String model = "Beetle";
  String color = "aquamarine";
  int mileage = 65536;
}
</example>
<results>
M t x00 x13 com.caucho.test.Car
  S x00 x05 model
  S x00 x06 Beetle

  S x00 x05 color
  S x00 x0a aquamarine

  S x00 x07 mileage
  I x00 x01 x00 x00
  z
</results>

<example title="A sparse array">
map = new HashMap();
map.put(new Integer(1), "fee");
map.put(new Integer(16), "fie");
map.put(new Integer(256), "foe");
</example>
<results>
M I x00 x00 x00 x01
  S x00 x03 fee

  I x00 x00 x00 x10
  S x00 x03 fie

  I x00 x00 x01 x00
  S x00 x03 foe

  z
</results>

<note>The <var>type</var> is chosen by the service.  Often it may be the
Java classname describing the service.</note>

<s3 title="Compact: object definition and instantiation">

<p>Hessian 2.0 has a compact object form where the field names
are only serialized once.  Following objects only need to serialize
their values</p>

<p>The object definition includes a manadatory type string, the number of
fields, the field names, and the values for the first object.
The first integer is the length of the type string.</p>

<def title="Object definition">
map ::= 'O' <var>int</var> type-string <var>int</var> <var>string</var>* <var>object</var>*
</def>

<p>The object instantiation creates a new object based on a previous
definition.</p>

<p>The integer is a reference to the object definition.</p>

<def title="Object instantiation">
map ::= 'o' <var>int</var> <var>object</var>*
</def>

<example title="Object serialization">
class Car {
  String color;
  String model;
}

out.writeObject(new Car("red", "corvette"));
out.writeObject(new Car("green", "civic"));
</example>
<results>
O x9b example.Car   -- type of the object length is int(12)
  x92               -- number of fields encoded as an int(2)
  x05 color         -- field names
  x05 model
  x03 red           -- data for object
  x08 corvette

o x91               -- second object x91 = int(1)
  x05 green
  x05 civic
</results>

</s3>

</s2>

<s2 title="ref" type="defun">
<p>An integer referring to a previous <var>list</var> or <var>map</var>
instance.  As each <var>list</var> or <var>map</var> is read from the
input stream, it is assigned the integer position in the stream,
i.e. the first <var>list</var> or <var>map</var> is '0', the next is '1', etc.
A later <var>ref</var> can then use the previous object.  Writers are not
required to generate <var>refs</var>, but parsers must be able to recognize them.
</p>

<def>
ref ::= R b32 b24 b16 b8
</def>

<p><var>ref</var> can refer to incompletely-read items.  For example, a
circular linked-list will refer to the first link before the entire list
has been read.</p>

<p>A possible implementation would add each <var>map</var> and <var>list</var> to an
array as it's read.  The <var>ref</var> will return the corresponding
object from the array.  To support circular structures, the
implementation would store the <var>map</var> or <var>list</var> immediately,
before filling in the object's contents.</p>

<p>Each &lt;list&gt; or &lt;array&gt; is stored into an array as it is
parsed.  &lt;ref&gt; selects one of the stored objects.  The first
object is numbered '0'.</p>

<example title="circular list">
list = new LinkedList();
list.head = 1;
list.tail = list;
</example>
<results>
M t x00 x0a LinkedList
  S x00 x04 head
  I x00 x00 x00 x01
  S x00 x04 tail
  R x00 x00 x00 x00
  z
</results>

<note><var>ref</var> only refers to <var>list</var> and <var>map</var> elements.
<var>string</var> and <var>binary</var>, in particular, will only share
references if they're wrapped in a <var>list</var> or <var>map</var>.</note>

</s2>

<s2 title="remote" type="defun">
<p>A reference to a remote object.  The remote has a
<var>type</var> and a utf-8 string representing the object's URL.</p>

<def>
remote ::= r t b16 b8 type-name S b16 b8 url
</def>

<results title="EJB Session Reference">
r t x00 x0c test.TestObj
  S x00 x24 http://slytherin/ejbhome?id=69Xm8-zW
</results>

</s2>

</s1>

<s1 title="Call">

<p>A Hessian call invokes a method on an object with an argument
list.  The object is specified by the container, e.g. for a HTTP
request, it's the HTTP URL.  The arguments are
specified by Hessian serialization.</p>

<def>
call ::= c x01 x00 <var>header</var>* m b16 b8 method-string (<var>object</var>)* z
</def>

<example title="obj.add2(2,3) call">
c x01 x00
  m x00 x04 add2
  I x00 x00 x00 x02
  I x00 x00 x00 x03
  z
</example>

<example title="obj.add2(2,3) reply">
r x01 x00
  I x00 x00 x00 x05
  z
</example>

<s2 title="Object Naming (non-normative)">

<p>
URLs are flexible
enough to encode object instances as well as simple
static service locations.  The URL uniquely identifies the
Hessian object.  Thus, Hessian can support
object-oriented services, e.g. naming services, entity beans, or
session beans, specified by the URL without requiring extra method parameters
or headers.</p>

<p>Object naming may use the query string convention that "?id=XXX"
names the object "XXX" in the given service.  This convention is recommented,
but not required.</p>

<p>For example, a stock quote service might have a
factory interface like http://foo.com/stock and object instances
like http://foo.com?id=PEET.  The factory interface would return valid
object references through the factory methods.</p>

</s2>

<s2 title="Object naming (non-normative)">

<p>As an example, the following format is used for EJB:</p>

<def>
http://hostname/hessian<var>/ejb-name</var>?id=<var>object-id</var>
</def>

<p><var>http://hostname/hessian</var> identifies the EJB container.
In Resin-EJB, this will refer to the EJB Servlet. 
"/hessian" is the servlet prefix (url-pattern.)  HTTP is just used as
an example; Hessian does not require the use of HTTP.
</p>

<p><var>/ejb-name</var>, the path info of the request, identifies the EJB name,
specifically the home interface.  EJB containers can contain several
entity and session beans, each with its own EJB home.  The <var>ejb-name</var>
corresponds to the ejb-name in the deployment descriptor.
</p>

<p><var>object-id</var> identifies the specific object.  For entity beans, the
object-id encodes the primary key.  For session beans, the object-id encodes
a unique session identifier.  Home interfaces have no ";ejbid=..." portion.
</p>

<example title="Example Entity Home Identifier">
http://localhost/hessian/my-entity-bean
</example>

<example title="Example Entity Bean Identifier">
http://localhost/hessian/my-entity-bean?ejbid=slytherin
</example>

<example title="Example Session Home Identifier">
http://localhost/hessian/my-session-bean
</example>

<example title="Example Session Bean Identifier">
http://localhost/hessian/my-session-bean?ejbid=M9Zs1Zm
</example>

</s2>

<s2 title="Methods and Overloading">

<p>Method names must be unique.  Two styles of overloading are
supported: overloading by number of argumetns and overloading
by argument types.  Overloading is permitted by
encoding the argument types in the method names.  The types of
the actual arguments must not be used to select the methods.</p>

<p>Method names beginning with <var>_hessian_</var> are reserved.</p>

<p>Servers should accept calls with either the mangled method name
or the unmangled method name.  Clients should send the mangled method name.</p>

<note>See the Java binding for a possible overloading scheme.</note>

<example>add(int a, int b)</example>
<results>add_int_int</results>
<example>add(double a, double b)</example>
<results>add_double_double</results>
<example>add(shopping.Cart cart, shopping.Item item)</example>
<results>add_shopping.Cart_shopping.Item</results>

</s2>

<s2 title="Arguments">

<p>Arguments immediately follow the method in positional order.
Argument values use Hessian's serialization.</p>

<p>All arguments share references, i.e. the reference list
starts with the first argument and continues for all other arguments.
This lets two arguments share values.</p>

<example title="remote.eq(bean, bean)">
bean = new qa.Bean("foo", 13);

System.out.println(remote.eq(bean, bean));
</example>
<results>
c x01 x00
  m x00 x02 eq
  M t x00 x07 qa.Bean
    S x00 x03 foo
    I x00 x00 x00 x0d
    z
  R x00 x00 x00 x00
  z
</results>

<p>The number and type of arguments are fixed by the remote method.
Variable length arguments are forbidden.  Implementations
may take advantage of the expected type to improve performance.</p>

</s2>

<s2 title="Headers">

<p>Headers are (string, object) pairs that preceed the arguments.</p>

<p>The value of the header can be any serialized object.</p>

<p>For example, a request might include a transaction context in a
header.</p>

<results title="Call with Distributed Transaction Context">
c x01 x00
  H x00 x0b transaction
  r t x00 x28 com.caucho.hessian.xa.TransactionManager
    S x00 x23 http://hostname/xa?ejbid=01b8e19a77
  m x00 x05 debug
  I x00 x03 x01 xcb
  z
</results>

</s2>

<s2 title="Versioning">

<p>The call and response tags include a major and minor byte.  The
current version is 1.0.</p>

</s2>

</s1>

<s1 title="Reply">

<def>
valid-reply ::= r x01 x00 <var>header</var>* <var>object</var> z
fault-reply ::= r x01 x00 <var>header</var>* <var>fault</var> z
</def>

<s2 title="Value">
  
<p>A successful reply returns a single value and possibly
some header information.  </p>
  
<example title="integer 5 result">
r x01 x00
  I x00 x00 x00 x05
  z
</example>

</s2>
<s2 title="Faults">
<p>Failed calls return a <var>fault</var>.</p>

<p>Each fault has a number of informative fields, expressed like
&lt;map&gt; entries.  The defined fields are <var>code</var>, <var>message</var>,
and <var>detail</var>. <var>code</var> is one of a short list of strings
defined below.  <var>message</var> is a user-readable message.
<var>detail</var> is an object representing the exception.  In Java,
<var>detail</var> will be a serialized exception.</p>

<results title="Remote Call throws FileNotFoundException">
r x01 x00
  f
  S x00 x04 code
  S x00 x10 ServiceException

  S x00 x07 message
  S x00 x0e File Not Found

  S x00 x06 detail
  M t x00 x1d java.io.FileNotFoundException
    z
  z
</results>

<deftable>
<tr><td>ProtocolException</td><td>The Hessian request has some sort of
syntactic error.
</td></tr><tr><td>NoSuchObjectException</td><td>The requested object does not exist.
</td></tr><tr><td>NoSuchMethodException</td><td>The requested method does not exist.
</td></tr><tr><td>RequireHeaderException</td><td>A required header was not understood
by the server.
</td></tr><tr><td>ServiceException</td><td>The called method threw an exception.
</td></tr></deftable>

</s2>

</s1>

<s1 title="Metadata (non-normative)">

<p>Metadata is handled by special method calls, methods beginning
with <var>_hessian_</var>.</p>

<p><var>_hessian_getAttribute(String&#160;key)</var> returns a string.
The following attributes are predefined by this spec:</p>

<deftable>
<tr><th>attribute</th><th>meaning
</th></tr><tr><td>java.api.class</td><td>Java interface for this URL
</td></tr><tr><td>java.home.class</td><td>Java interface for this service
</td></tr><tr><td>java.object.class</td><td>Java interface for a service object
</td></tr><tr><td>java.ejb.primary.key.class</td><td>Java EJB primary key class
</td></tr></deftable>

<p>"java.api.class" returns the client proxy's Java API class
for the current URL.  "java.home.class" returns the API class for the
factory URL, i.e. without any "?id=XXX" query string.  "java.object.class"
returns the API class for object instances.</p>

<p>In the case of services with no object instances, i.e.
non-factory services, all three attributes will return the
same class name.</p>

<s2 title="Obsolete meta data properties">

<deftable>
<tr><th>attribute</th><th>meaning
</th></tr><tr><td>home-class</td><td>Java class for the home interface.
</td></tr><tr><td>remote-class</td><td>Java class for the object interface.
</td></tr><tr><td>primary-key-class</td><td>Java class for the primary key.
</td></tr></deftable>

</s2>

</s1>

<s1 title="Micro Hessian">

<p>A "Micro Hessian" implementation may omit support for the "double" type.
</p>

</s1>

<s1 title="Bytecode map">

<p>Hessian is organized as a bytecode protocol.  A Hessian
implementation is essentially a big switch statement on the initial
bytecode.</p>

<def title="Encoding">
x00 - x1f    # utf-8 string length 0-32
x20 - x2f    # binary data length 0-16
x30 - x37    # reserved
x38 - x3f    # long from -x40000 to x3ffff
x40 - x41    # reserved
x42          # 8-bit binary data final chunk ('B')
x43          # reserved
x44          # 64-bit IEEE encoded double ('D')
x45          # reserved
x46          # boolean false ('F')
x47 - x48    # reserved
x49          # 32-bit signed integer ('I')
x4a - x4b    # reserved
x4c          # 64-bit signed long integer ('L')
x4d          # map with optional type ('M')
x4e          # null ('N')
x4f          # object definition ('O')
x50          # reference to 1-255th map/list
x51          # reference to 1-65536th map/list
x52          # reference to map/list - integer ('R')
x53          # utf-8 string final chunk ('S')
x54          # boolean true ('T')
x55          # reserved
x56          # list/vector ('V')
x57          # reserved
x58          # utf-8 xml final chunk ('X')
x59 - x62    # reserved
x62          # 8-bit binary data non-final chunk ('b')
x63          # reserved ('c' call for RPC)
x64          # UTC time encoded as 64-bit long milliseconds since epoch ('d')
x65          # reserved
x66          # reserved ('f' for fault for RPC)
x67          # double 0.0
x68          # double 1.0
x69          # double represented as byte (-128.0 to 127.0)
x6a          # double represented as short (-32768.0 to 327676.0)
x6b          # double represented as 32-bit int
x6c          # list/vector length ('l')
x6d          # reserved ('m' method for RPC call)
x6e          # list/vector compact length
x6f          # object instance ('o')
x70          # double represented as float
x71          # reserved
x72          # reserved ('r' reply for message/RPC)
x73          # utf-8 string non-final chunk ('s')
x74          # map/list type ('t')
x75          # type-ref
x76          # compact vector ('v')
x77          # long encoded as 32-bit int
x78          # utf-8 XML non-final chunk ('x')
x79          # reserved
x7a          # list/map terminator ('z')
x7b - x7f    # reserved
x80 - xbf    # one-byte compact int (-x10 to x3f, x90 is 0)
xc0 - xcf    # two-byte compact int (-x800 to x3ff)
xd0 - xd7    # three-byte compact int (-x40000 to x3ffff)
</def>

</s1>

<s1 title="Copyright and Licensing">

<p>
© Copyright 2000-2004 Caucho Technology, Inc. All Rights Reserved.
</p>

<p>Any party may implement this protocol for any purpose without royalty
or license fee, provided that the implementation conforms to this
specification.   Caucho Technology reserves the right to create a
test suite, freely available without royalty or license fee, to
validate implementation conformance.  The limited permissions granted
herein are perpetual and may not be revoked by Caucho Technology or
its successors or assigns.</p>

<p>This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it
or assist in its implementation may be prepared, copied, published and
distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and these paragraphs are
included on all such copies and derivative works.</p>

<p>This document and the information contained herein is provided on an
"AS IS" basis and CAUCHO TECHNOLOGY DISCLAIMS ALL WARRANTIES, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.</p>

</s1>

<s1 title="Changes">

<s2 title="changes in 2.0">

<ul>
<li>Added envelope ('E') syntax.</li>
</ul>

</s2>

<s2 title="changes in 1.0.2">

<ul>
<li>Clarified that length of XML and strings is in characters (Petr Gladkikh)
</li></ul>
</s2>

<s2 title="changes in 1.0">

<ul>
<li>Removed unidirectional messages.
</li></ul>
</s2>

<s2 title="changes in V3">

<ul>
<li>Added unidirectional messages
</li><li>Removed 'v' from reply
</li><li>changed length code to 'l'
</li><li>made <var>type</var> and <var>length</var> optional
</li></ul>

</s2>

<s2 title="changes in V2">

<ul>
<li>EJB naming: clarified examples especially for session beans (John Mitchell)
</li><li>Formal definitions: clarified grammar and added missing object (John Mitchell)
</li><li>Formal definitions: initial binary should use 'b' (John Mitchell)
</li></ul>

</s2>

</s1>
</body></document>
