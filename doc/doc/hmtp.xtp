<document>
  <header>
    <product>resin</product>
    <title>HMTP</title>
    <type>contents</type>

    <description>
      <p>
      HMTP (Hessian Message Transport Protocol) is an asynchronous,
      object-oriented messaging framework, designed around small, interactive
      message packets, a brokered-agent topology and based on the <a href="http://hessian.caucho.com/">Hessian</a> protocol and <a href="http://xmpp.org">XMPP</a> (Jabber).
      </p>
    </description>
  </header>

<body>

<localtoc/>

<s1 title="Quick Start">

<s2 title="Server sendMessage example">

<p>Sending a message from a servlet to an internal service is a
basic HMTP use case.  The message service implements the
<code>sendMessage</code> method to receive messages.  Since HMTP is
a streaming API like <code>java.io.OutputStream</code>, the sending
method is the same as the receiving method, <code>sendMessage</code>.</p>

<p>HMTP messages are addressed using a JID (Jabber ID), which looks like
<code>user@domain</code> or <code>user@domain/resource</code>.  The
second <code>user@domain/resource</code> is used for temporary
client agent addresses, e.g. a user logged into messaging with
a cellphone.</p>

<p>In the example, the servlet obtains a <code>HmtpConnection</code> using
the Web Beans <code>@javax.webbeans.In</code> injection annotation, and
sends the message.</p>

<p>By extending <code>GenericService</code>, the service automatically gains
a queuing ability.  The broker will queue the message and spawn a new thread
before calling the service's <code>sendMessage</code>, in order to isolate
the receiver from the sender.  Advanced applications can disable the
queue if appropriate.</p>

<example title="LogService.java">
package example;

import com.caucho.hemp.broker.GenericService;
import java.io.Serializable;
import java.util.logging.*;

public class LogService extends GenericService
{
  private static final Logger log
    = Logger.getLogger(LogService.class.getName());

  @Override
  public void sendMessage(String to, String from, Serializable value)
  {
    log.info(this + " sendMessage from=" + from + " value=" + value);
  }
}
</example>

<example title="TestServlet.java">
package example;

import javax.servlet.*;
import javax.webbeans.In;
import com.caucho.hmtp.HmtpConnectionFactory;
import com.caucho.hmtp.HmtpConnection;

public class TestServlet extends GenericServlet
{
  @In HmtpConnectionFactory _factory;

  public void service(ServletRequest req, ServletResponse response)
  {
    HmtpConnection conn = _factory.getConnection("demo@localhost", null);

    try {
      conn.sendMessage("test@localhost", "Hello, world!");
    } finally {
      conn.close();
    }
  }
}
</example>


<example title="WEB-INF/resin-web.xml">
&lt;web-app xmlns="http://caucho.com/ns/resin">

    &lt;bean class="com.caucho.hemp.broker.HempBroker"/>

    &lt;bean name="test@localhost" class="example.LogService"/>

&lt;/web-app>
</example>

</s2>

<s2 title="Client queryGet (RPC) example">

<p>Remote calls are another primary use for HMTP.  In this example, we
just query a service for some basic information.  In HMTP, queries
are bidirections: the server can also query the client.  And the application
can also use the messaging in the previous example.</p>

<example title="TestService.java">
package example;

import com.caucho.hemp.broker.GenericService;
import java.io.Serializable;
import java.util.logging.*;

public class TestService extends GenericService
{
  private static final Logger log
    = Logger.getLogger(LogService.class.getName());

  @Override
  public boolean sendQueryGet(long id, String to, String from,
                              Serializable query)
  {
    if (query instanceof TestQuery) {
      getStream().sendQueryResult(id, to, from, "hello response");
    }
    else {
      return super.sendQueryGet(id, to, from, query);
    }
  }
}
</example>

<example title="TestClient.java">
package example;

import com.caucho.hmtp.client.HmtpClient;

public class TestClient
{
  public static void main(String []args)
    throws Exception
  {
    HmtpClient client = new HmtpClient("http://localhost:8080/hmtp");
    client.connect();
    client.login("user@localhost", null);

    Object value = client.queryGet("test@localhost", new TestQuery());

    System.out.println(value);

    client.close();
  }
}
</example>


<example title="WEB-INF/resin-web.xml">
&lt;web-app xmlns="http://caucho.com/ns/resin">

    &lt;bean class="com.caucho.hemp.broker.HempBroker"/>

    &lt;bean name="test@localhost" class="example.TestService"/>

    &lt;servlet-mapping url-pattern="/hmtp"
                      servlet-class="com.caucho.hemp.servlet.HempServlet"/>

&lt;/web-app>
</example>

</s2>

</s1>

<s1 title="Brokered Agent Messaging (BAM)">

<p>Applications using HMTP will generally follow a Brokered Agent
Messaging pattern, which is basically a hub-and-spoke messaging topology where
the agents act as dynamic services: joining and detaching from the broker
as the application progresses.</p>

<p>Services and clients register one or more agents with the HmtpBroker and
then send messages between the agents.  Each remote client will register
a local agent with the local HMTP broker.  Services will register one or
more agents with the broker.   In a tic-tac-toe game, the game
instance might register two agents: one for each player in a particular
game.</p>

<figure title="Tic-Tac-Toe Agents" src="tictactoe-game.png"/>

<p>The diagram above has four agents: two agents for the game's players, and
one agent for each logged-in user.  <var>tictactoe@host.com/1</var> is the game's agent
for player #1, and <var>harry@host.com/x</var> is Harry's agent for his
flash client.  In the tic-tac-toe game, each user's agent talks to the
matching game player, so <var>harry@host.com/x</var> always
talks to <var>tictactoe@host.com/1</var>, and <var>draco@host.com/y</var>
always talks to <var>tictactoe@host.com/1</var>.</p>

<p>The game's agents are ephemeral.  When a new game begins, a 
<code>TicTacTocGame</code> instance registers two new agents for the
new game, with unique names, e.g. <var>tictactoe@host.com/3</var> and
<var>tictactoe@host.com/4</var>.  When the game ends, the instance will
unregister its agents.</p>

<p>Because the game's agents are only created when a game begins, the
tic-tac-toe game has a persistent agent for registration,
<var>tictactoe@host.com</var>.  When Harry logs on, the client will
send a query to <var>tictactoe@host.com</var> asking for a new game.  As soon
as Draco asks for a match, the registration server will create a new
game instance and tell Harry's client the name of his
player agent, <var>tictactoe@host.com/1</var>.</p>

<figure title="Tic-Tac-Toe Registration" src="tictactoe-registration.png"/>

</s1>

<s1 title="XMPP (Jabber)">

<p>HMTP is an adaptation of the <a href="http://xmpp.org">XMPP</a> (Jabber)
instant messaging protocol.  Where XMPP (Xml Messaging and Presence Protocol)
is based on XML, HMTP (Hessian Message Transport Presence Protocol) is
based on Hessian.  Because HMTP is designed to follow XMPP, its
architecture and protocols are essentially identical until the very
lowest layer, where HMTP substitutes Hessian for XML.</p>

<p>Because of the close relationship to XMPP, you may want to browse the
XMPP specifications for a deeper understanding of how HMTP works.  Since
XMPP is only a wire protocol, not an API, it does not include all of the
HMTP classes, but the architecture remains the same.</p>

<p>The primary advantages HMTP offers over XMPP include the performance
advantages of Hessian over XML, and more importantly a more strict layering
than XMPP provides.  Because the payloads of the HMTP messages are all
<code>Serializable</code>, applications have enormous flexibility in
developing their own messages using application objects.  In contrast,
XMPP messages are always XML, so applications are not only restricted to
XML data, but also must create their own XML parsers and formatters.</p>

</s1>

<s1 title="Packet types">

<p>HMTP provides three categories of packets: messages, queries (rpc), and
presence announcements.  Messages and queries are typically the bulk of the
packets, while presence announcements are used rarely.</p>

<p>Messages are unidirectional fire-and-forget packets.</p>

<p>Queries are request-response pairs.  Each request must have a corresponding
response or error.</p>

<p>Presence announcements are used to organize subscriptions.  There are
presence announcements to subscribe and unsubscribe, and presence notifications
that a user has logged on, sent to all other users subscribed to
his presence.</p>

<s2 title="Message Packets">

<p>The main Message packet contains a target ("to"), a sender ("from"),
and a payload ("value").  In HMTP, the payload can be any serializable
value.  Example messages could be IM text messages, administration console
graph, game updates, or updated stock quotes.  Since HMTP is bidirectional,
messages can flow to and from any client.</p>

<ul>
<li>Message - sends a message to a resource</li>
<li>MessageError - sends a message error to a resource</li>
</ul>

</s2>

<s2 title="Query Packets">

<p>Query packages are RPC get and set packets with a matching response
or error.  Because the query will always have a matching response packet
or an error packet, clients can either block for the result or
attach a callback.</p>

<p>Like the other packets, queries are bidirectional, so a service can query
a client as well as the usual client querying the server.</p>

<p>Query packets have an associated <var>id</var> field to match requests
with responses.  The client will increment the <var>id</var> for each
new query.</p>

<ul>
<li>QueryGet - sends an information request</li>
<li>QuerySet - sends an action query </li>
<li>QueryResponse - returns a response</li>
<li>QueryError - returns an error</li>
</ul>

</s2>

<s2 title="Presence Packets">

<p>Presence packets send specialized information for subscription
notification.  Many applications will not need to use any presence
packets at all.</p>



</s2>

</s1>

<s1 title="Addressing (JIDs)">

<p>HMTP resources all have unique identifiers called JIDs (Jabber IDs).
The id looks like:</p>

<def title="JID format">
<var>user</var>@<var>domain</var>/<var>resource</var>
</def>

<p>The <var>resource</var> and <var>user</var> are optional.</p>

<deftable title="example jids">
<tr>
  <th>jid</th>
  <th>description</th>
</tr>
<tr>
  <td>ferg@foo.com</td>
  <td>IM user resource</td>
</tr>
<tr>
  <td>ferg@foo.com/xB8</td>
  <td>User login agent, i.e. the HMTP address corresponding to a logged
in IM session.</td>
</tr>
<tr>
  <td>tictactoe@foo.com</td>
  <td>tic-tac-toc game manager resource</td>
</tr>
<tr>
  <td>tictactoe@foo.com/1</td>
  <td>player #1 agent of a tic-tac-toe game</td>
</tr>
<tr>
  <td>tictactoe@foo.com/2</td>
  <td>player #2 agent of a tic-tac-toe game</td>
</tr>
<tr>
  <td>tictactoe@foo.com/3</td>
  <td>player #1 agent of a tic-tac-toe game #2</td>
</tr>
<tr>
  <td>tictactoe@foo.com/4</td>
  <td>player #2 agent of a tic-tac-toe game #2</td>
</tr>
<tr>
  <td>myroom@foo.com</td>
  <td>chatroom instance</td>
</tr>
<tr>
  <td>myroom@foo.com/harry</td>
  <td>chatroom nickname for user #1</td>
</tr>
<tr>
  <td>myroom@foo.com/draco</td>
  <td>chatroom nickname for user #2</td>
</tr>
<tr>
  <td>announcements@foo.com</td>
  <td>publish/subscribe resource</td>
</tr>
</deftable>

</s1>

<s1 title="API">

<s2 title="Client API">

<s3 title="HmtpConnection">

<def title="HmtpConnection">
package com.caucho.hmtp;

public interface HmtpConnection
{
  String getJid();

  boolean isClosed();
  void close();
  
  void setMessageHandler(MessageStream handler);
  void setQueryHandler(QueryStream handler);
  void setPresenceHandler(PresenceStream handler);

  void sendMessage(String to, Serializable value);

  Serializable queryGet(String to, Serializable query);
  Serializable querySet(String to, Serializable query);

  void queryGet(String to, Serializable query, QueryCallback callback);
  void querySet(String to, Serializable query, QueryCallback callback);

  void presence(Serializable []data);
  void presence(String to, Serializable []data);
  void presenceUnavailable(Serializable []data);
  void presenceUnavailable(String to, Serializable []data);
  void presenceProbe(String to, Serializable []data);
  void presenceSubscribe(String to, Serializable []data);
  void presenceSubscribed(String to, Serializable []data);
  void presenceUnsubscribe(String to, Serializable []data);
  void presenceUnsubscribed(String to, Serializable []data);
  void presenceError(String to, Serializable []data, HmtpError error);
  
  HmtpStream getStream();
}
</def>

</s3>

<s3 title="HmtpConnectionFactory">

<def title="HmtpConnectionFactory">
package com.caucho.hmtp;

public interface HmtpConnectionFactory
{
  HmtpConnection getConnection(String uid, String password);
}
</def>

</s3>
<s3 title="QueryCallback">

<def title="QueryCallback">
package com.caucho.hmtp;

public interface QueryCallback
{
  void onQueryResult(String to, String from, Serializable value);
  
  void onQueryError(String to, String from, Serializable value,
                    HmtpError error);
}
</def>
</s3>

</s2>

<s2 title="Remote Client API">

<s3 title="HmtpClient">

<def title="HmtpClient">
package com.caucho.hmtp;

public class HmtpClient implements HmtpConnection
{
  public HmtpClient(String url);

  public void connect() throws IOException;

  public void login(String uid, String password);

  // HmtpConnection methods
  String getJid();

  boolean isClosed();
  void close();
  
  void setMessageHandler(MessageStream handler);
  void setQueryHandler(QueryStream handler);
  void setPresenceHandler(PresenceStream handler);

  void sendMessage(String to, Serializable value);

  Serializable queryGet(String to, Serializable query);
  Serializable querySet(String to, Serializable query);

  void queryGet(String to, Serializable query, QueryCallback callback);
  void querySet(String to, Serializable query, QueryCallback callback);

  void presence(Serializable []data);
  void presence(String to, Serializable []data);
  void presenceUnavailable(Serializable []data);
  void presenceUnavailable(String to, Serializable []data);
  void presenceProbe(String to, Serializable []data);
  void presenceSubscribe(String to, Serializable []data);
  void presenceSubscribed(String to, Serializable []data);
  void presenceUnsubscribe(String to, Serializable []data);
  void presenceUnsubscribed(String to, Serializable []data);
  void presenceError(String to, Serializable []data, HmtpError error);
  
  HmtpStream getStream();
}
</def>
</s3>

</s2>

<s2 title="Protocol(Packet) API">

<s3 title="MessageStream">

<def title="MessageStream">
package com.caucho.hmtp;

public interface MessageStream
{
  public void sendMessage(String to, String from, Serializable value);
  
  public void sendMessageError(String to, String from, Serializable value,
			       HmtpError error);
}
</def>

</s3>

<s3 title="QueryStream">

<def title="QueryStream">
package com.caucho.hmtp;

public interface QueryStream
{
  boolean sendQueryGet(long id, String to, String from, Serializable query);
  boolean sendQuerySet(long id, String to, String from, Serializable query);

  void sendQueryResult(long id, String to, String from, Serializable value);
  void sendQueryError(long id, String to, String from, Serializable query,
                      HmtpError error);
}
</def>

</s3>

<s3 title="PresenceStream">

<def title="PresenceStream">
package com.caucho.hmtp;

public interface PresenceStream
{
  void sendPresence(String to, String from, Serializable []data);
  void sendPresenceUnavailable(String to, String from, Serializable []data);
  void sendPresenceProbe(String to, String from, Serializable []data);
  void sendPresenceSubscribe(String to, String from, Serializable []data);
  void sendPresenceSubscribed(String to, String from, Serializable []data);
  void sendPresenceUnsubscribe(String to, String from, Serializable []data);
  void sendPresenceUnsubscribed(String to, String from, Serializable []data);
  void sendPresenceError(String to, String from, Serializable []data,
                         HmtpError error);
}
</def>

</s3>

<s3 title="HmtpStream">

<def title="HmtpStream">
package com.caucho.hmtp;

public interface HmtpStream
  extends MessageStream, QueryStream, PresenceStream
{
}
</def>

</s3>

</s2>

<s2 title="Service APIs">

<s3 title="HmtpBroker">

<def title="HmtpBroker">
package com.caucho.hmtp;

public interface HmtpBroker
  extends HmtpStream, HmtpConnectionFactory
{
  void addResourceManager(ResourceManager manager);
    
  HmtpConnection registerResource(String jid, HmtpResource resource);
}
</def>

</s3>

<s3 title="HmtpResource">

<def title="HmtpResource">
package com.caucho.hmtp;

public interface HmtpResource
{
  public String getJid();
  
  public HmtpResource lookupResource(String jid);

  public void onLogin(String jid);
  public void onLogout(String jid);

  public HmtpStream getCallbackStream();
  
  public HmtpStream getOutboundFilter(HmtpStream stream);
  public HmtpStream getInboundFilter(HmtpStream stream);
}
</def>

</s3>

<s3 title="ResourceManager">

<def title="ResourceManager">
package com.caucho.hmtp;

public interface ResourceManager
{
  public void setBroker(HmtpBroker broker);
  
  public HmtpResource lookupResource(String jid);
}
</def>

</s3>

<s3 title="HmtpService">

<def title="HmtpService">
package com.caucho.hmtp;

public interface HmtpService
  extends HmtpResource, HmtpStream
{
}
</def>

</s3>

</s2>

</s1>

  </body>
</document>