<document>
  <header>
    <product>resin</product>
    <title>BAM</title>
    <type>contents</type>

    <description>
      <p>
      BAM (Brokered Agent Messaging) is an asynchronous,
      object-oriented messaging framework, designed around small, interactive
      message packets, a brokered-agent topology and based on the <a href="http://hessian.caucho.com/">Hessian</a> protocol and <a href="http://xmpp.org">XMPP</a> (Jabber).
      </p>
    </description>
  </header>

<body>

<localtoc/>

<s1 title="Quick Start">

<s2 title="Queued message example">

<p>Sending a message from one agent to another is a basic BAM use case.
Typical applications include message queuing, chat text, game updates,
Atom/RSS updates, pub/sub messaging, and event notification
for administration consoles. In this example, a servlet sends a message
to an internal logging service.</p>

<p>The sending agent sends a message using <code>message</code> with
the jid address of the target agent (to), and a message payload.
The receiving agent implements the <code>message</code> method to
receive messages.  Since BAM is a streaming API like
<code>java.io.OutputStream</code>, the sending method is the same as
the receiving method, <code>message</code>.</p>

<p>BAM messages use a JID (Jabber ID) for addressing, which looks like
<code>user@domain</code> or <code>user@domain/resource</code>.  The
second <code>user@domain/resource</code> is used for dynamic
agent, e.g. a user logged into messaging with a cellphone.</p>

<p>The message payload can be any serializable object.  Because Hessian
is available for many languages, the message can easily interoperate with
RIA platforms like Flash.</p>

<p>Since BAM uses a broker/agent or hub-and-spoke messaging model, all
messages go through the broker to be routed to the target agent.  Each
service and client will register an agent with the broker and receive
a unique JID for the routing.</p>

<figure src="hmtp-log.png"/>

<p>Writing a HMTP client involves the following steps:</p>

<ol>
<li>Create a <code>BamClient</code></li>
<li>Optionally: setting message handlers to receive messages</li>
<li>Sending messages</li>
<li>Close the connection</li>
</ol>

<p>In the example, the servlet creates a <code>BamClient</code> 
and sends the message.  Opening
a client registers an agent with the broker.  When the connection
closes, it will unregister the agent.</p>

<example title="TestServlet.java">
package example;

import javax.servlet.*;
import com.caucho.bam.BamClient;

public class TestServlet extends GenericServlet
{
  private BamClient _client = new BamClient();

  public void service(ServletRequest req, ServletResponse response)
  {
    _client.message("test@localhost", "Hello, world!");
  }
}
</example>

<p>Writing a HMTP Service involves the following steps:</p>

<ol>
<li>Implementing <code>BamService</code> (usually by extending <code>SimpleBamService</code>)</li>
<li>Registering the <code>BamService</code> with <code>BamBroker</code> and
a jid using <code>&lt;bam-service></code></li>
<li>Receiving messages to the implemented <code>BamStream</code> (or overriding <code>BamStream</code> methods in <code>SimpleBamService</code>)</li>
<li>Sending messages to other agents using the
broker's <code>getBrokerStream</code>.</li>
</ol>

<p>By configuring <code>&lt;bam-service></code>, the service automatically
gains a queuing ability.  The broker will queue the message and spawn a
new thread before calling the service's <code>message</code>, in order
to isolate the receiver from the sender.  Advanced applications can
disable the queue if appropriate.</p>

<example title="LogService.java">
package example;

import com.caucho.bam.SimpleBamService;
import java.io.Serializable;
import java.util.logging.*;

public class LogService extends SimpleBamService
{
  private static final Logger log
    = Logger.getLogger(LogService.class.getName());

  @Override
  public void message(String to, String from, Serializable value)
  {
    log.info(this + " message from=" + from + " value=" + value);
  }
}
</example>

<p>The HMTP configuration consists of the broker and the service
configured with <a href="resin-ioc.xtp">Resin IoC</a>.</p>

<example title="WEB-INF/resin-web.xml">
&lt;web-app xmlns="http://caucho.com/ns/resin">

    &lt;bam-service name="test@localhost" class="example.LogService"/>

&lt;/web-app>
</example>

</s2>

<s2 title="Client queryGet (RPC) example">

<p>Remote calls are another primary use for BAM.  In this example, we
just query a service for some basic information.  In BAM, queries
are bidirectional: the server can also query the client.  And the application
can also use the messaging in the previous example.</p>

<figure src="hmtp-client.png"/>

<p>To implement the server side of an RPC call, the service implements
<code>queryGet</code> or <code>querySet</code>, and examines the
query to see if it understands the query class.  If the service does not
understand the query, it will return false (or call the super
method for <code>SimpleBamService</code>).  If a query returns true, it
must either send a query response or query error with
the same <code>id</code>, so the waiting client will always receive a
response.</p>

<p>The type-based query system gives enormous flexibility in creating services.
Services can be mash-ups of capabilities just by adding new query types.</p>

<example title="TestService.java">
package example;

import com.caucho.bam.SimpleBamService;
import com.caucho.bam.annotation.QueryGet;

public class TestService extends SimpleBamService
{
  @QueryGet
  public boolean queryGet(long id, String to, String from,
                          TestQuery query)
  {
    getBrokerStream().sendQueryResult(id, to, from, "hello response");

    return true;
  }
}
</example>

<p>In this example, we'll use a remote client, <code>HmtpClient</code>,
which extends the <code>BamConnection</code> API to provide extra calls
for connecting and logging on to the server.  For local messages, we could
use <code>BamClient</code> instead.  The message passing calls
are identical.</p>

<p>When you create a <code>HmtpClient</code>, you'll send it the URL
of the HMTP service, then call <code>connect()</code> and <code>login</code>
to authenticate.  The <code>login()</code> method will register an
agent with the broker, letting the client send and receive messages.</p>

<p>This example sends a RPC query to <var>test@localhost</var>.
RPC calls in HMTP are typed.  Each query class might execute a different
query on the server.  In this case we create a trivial <code>TestQuery</code>.
</p>

<example title="TestClient.java">
package example;

import com.caucho.hmtp.client.HmtpClient;

public class TestClient
{
  public static void main(String []args)
    throws Exception
  {
    HmtpClient client = new HmtpClient("http://localhost:8080/hmtp");
    client.connect();
    client.login("user@localhost", null);

    Object value = client.queryGet("test@localhost", new TestQuery());

    System.out.println(value);

    client.close();
  }
}
</example>

<p>The configuration for a remote service now has three components:</p>

<ol>
<li>Any registered <code>BamService</code>, e.g. the TestService</li>
<li>The exposed HMTP service protocol, implemented
with <code>HempServlet</code></li>
</ol>

<example title="WEB-INF/resin-web.xml">
&lt;web-app xmlns="http://caucho.com/ns/resin">

    &lt;bam-service name="test@localhost" class="example.TestService"/>

    &lt;servlet-mapping url-pattern="/hmtp"
                     servlet-class="com.caucho.hemp.servlet.HempServlet"/>

&lt;/web-app>
</example>

</s2>

</s1>

<s1 title="Brokered Agent Messaging (BAM)">

<p>Applications using BAM will generally follow a Brokered Agent
Messaging pattern, which is basically a hub-and-spoke messaging topology where
the agents act as dynamic services: joining and detaching from the broker
as the application progresses.</p>

<p>Services and clients register one or more agents with the BamBroker and
then send messages between the agents.  Each remote client will register
a local agent with the local broker.  Services will register one or
more agents with the broker.   In a tic-tac-toe game, the game
instance might register two agents: one for each player in a particular
game.</p>

<figure title="Tic-Tac-Toe Agents" src="tictactoe-game.png"/>

<p>The diagram above has four agents: two agents for the game's players, and
one agent for each logged-in user.  <var>tictactoe@host.com/1</var> is the game's agent
for player #1, and <var>harry@host.com/x</var> is Harry's agent for his
flash client.  In the tic-tac-toe game, each user's agent talks to the
matching game player, so <var>harry@host.com/x</var> always
talks to <var>tictactoe@host.com/1</var>, and <var>draco@host.com/y</var>
always talks to <var>tictactoe@host.com/1</var>.</p>

<p>The game's agents are ephemeral.  When a new game begins, a 
<code>TicTacTocGame</code> instance registers two new agents for the
new game, with unique names, e.g. <var>tictactoe@host.com/3</var> and
<var>tictactoe@host.com/4</var>.  When the game ends, the instance will
unregister its agents.</p>

<p>Because the game's agents are only created when a game begins, the
tic-tac-toe game has a persistent agent for registration,
<var>tictactoe@host.com</var>.  When Harry logs on, the client will
send a query to <var>tictactoe@host.com</var> asking for a new game.  As soon
as Draco asks for a match, the registration server will create a new
game instance and tell Harry's client the name of his
player agent, <var>tictactoe@host.com/1</var>.</p>

<figure title="Tic-Tac-Toe Registration" src="tictactoe-registration.png"/>

</s1>

<s1 title="XMPP (Jabber)">

<p>BAM is an adaptation of the <a href="http://xmpp.org">XMPP</a> (Jabber)
instant messaging protocol.  Where XMPP (Xml Messaging and Presence Protocol)
is based on XML, HMTP (Hessian Message Transport Protocol) is
based on Hessian.  Because BAM is designed to follow XMPP, its
architecture and protocols are essentially identical until the very
lowest layer.</p>

<p>Because of the close relationship to XMPP, you may want to browse the
XMPP specifications for a deeper understanding of how HMTP works.  Since
XMPP is only a wire protocol, not an API, it does not include all of the
HMTP classes, but the architecture remains the same.</p>

<p>The primary advantages HMTP offers over XMPP include the performance
advantages of Hessian over XML, and more importantly a more strict layering
than XMPP provides.  Because the payloads of the HMTP messages are all
<code>Serializable</code>, applications have enormous flexibility in
developing their own messages using application objects.  In contrast,
XMPP messages are always XML, so applications are not only restricted to
XML data, but also must create their own XML parsers and formatters.</p>

</s1>

<s1 title="Packet types">

<p>BAM provides three categories of packets: messages, queries (rpc), and
presence announcements.  Messages and queries are typically the bulk of the
packets, while presence announcements are used rarely.</p>

<p>Messages are unidirectional fire-and-forget packets.  They can be
used for queuing systems as a replacement JMS queues.</p>

<p>Queries are request-response pairs.  Each request must have a corresponding
response or error.</p>

<p>Presence announcements are used to organize subscriptions.  There are
presence announcements to subscribe and unsubscribe, and presence notifications
that a user has logged on, sent to all other users subscribed to
his presence.</p>

<s2 title="Message Packets">

<p>The main Message packet contains a target ("to"), a sender ("from"),
and a payload ("value").  In BAM, the payload can be any serializable
value.  Example messages could be IM text messages, queued tasks,
administration console graph, game updates, or updated stock quotes.
Since BAM is bidirectional, messages can flow to and from any client.</p>

<ul>
<li>Message - sends a message to a resource</li>
<li>MessageError - sends a message error to a resource</li>
</ul>

</s2>

<s2 title="Query Packets">

<p>Query packages are RPC get and set packets with a matching response
or error.  Because the query will always have a matching response packet
or an error packet, clients can either block for the result or
attach a callback.</p>

<p>Like the other packets, queries are bidirectional, so a service can query
a client as well as the usual client querying the server.</p>

<p>Query packets have an associated <var>id</var> field to match requests
with responses.  The client will increment the <var>id</var> for each
new query.</p>

<ul>
<li>QueryGet - sends an information request</li>
<li>QuerySet - sends an action query </li>
<li>QueryResponse - returns a response</li>
<li>QueryError - returns an error</li>
</ul>

</s2>

<s2 title="Presence Packets">

<p>Presence packets send specialized information for subscription
notification.  Many applications will not need to use any presence
packets at all.</p>

<ul>
<li>Presense - sends a presence (login) notification</li>
<li>PresenseUnavailable - sends unavailable (logout) notification</li>
<li>PresenseProbe - query probe for IM clients</li>
<li>PresenseSubscribe - request to subscribe to a service</li>
<li>PresenseSubscribed - acknowledgement of a subscription</li>
<li>PresenseUnsubscribe - notification of an unsubscription</li>
<li>PresenseUnsubscribed - notification of an unsubscription</li>
<li>PresenseError - error message</li>
</ul>


</s2>

</s1>

<s1 title="Addressing (JIDs)">

<p>BAM resources all have unique identifiers called JIDs (Jabber IDs), which
look and act like extended email addresses.  Because IM applications can
have multiple connections for the same user, each address has an
optional resource providing a unique name for the connection.</p>

<p>The id looks like:</p>

<def title="JID format">
<var>user</var>@<var>domain</var>/<var>resource</var>
</def>

<p>The <var>resource</var> and <var>user</var> are optional.</p>

<deftable title="example jids">
<tr>
  <th>jid</th>
  <th>description</th>
</tr>
<tr>
  <td>ferg@foo.com</td>
  <td>IM user resource</td>
</tr>
<tr>
  <td>ferg@foo.com/xB8</td>
  <td>User login agent, i.e. the BAM address corresponding to a logged
in IM session.</td>
</tr>
<tr>
  <td>batch@foo.com</td>
  <td>Application queuing service (like an EJB message driven bean)</td>
</tr>
<tr>
  <td>mail@foo.com</td>
  <td>Mail notification service</td>
</tr>
<tr>
  <td>tictactoe@foo.com</td>
  <td>tic-tac-toc game manager resource</td>
</tr>
<tr>
  <td>tictactoe@foo.com/1</td>
  <td>player #1 agent of a tic-tac-toe game</td>
</tr>
<tr>
  <td>tictactoe@foo.com/2</td>
  <td>player #2 agent of a tic-tac-toe game</td>
</tr>
<tr>
  <td>tictactoe@foo.com/3</td>
  <td>player #1 agent of a tic-tac-toe game #2</td>
</tr>
<tr>
  <td>tictactoe@foo.com/4</td>
  <td>player #2 agent of a tic-tac-toe game #2</td>
</tr>
<tr>
  <td>myroom@foo.com</td>
  <td>chatroom instance</td>
</tr>
<tr>
  <td>myroom@foo.com/harry</td>
  <td>chatroom nickname for user #1</td>
</tr>
<tr>
  <td>myroom@foo.com/draco</td>
  <td>chatroom nickname for user #2</td>
</tr>
<tr>
  <td>announcements@foo.com</td>
  <td>publish/subscribe resource</td>
</tr>
</deftable>

</s1>

<s1 title="Services">

<p>Resin includes a number of predefined BAM services for JMS compatibility,
logging, and mail messages.  The services are all configured with
<code>&lt;bam-service></code>.</p>

<deftable title="Predefined Services">
<tr>
  <th>uri</th>
  <th>class</th>
  <th>description</th>
</tr>
<tr>
  <td>caucho.jms</td>
  <td>com.caucho.hemp.services.BamJmsService</td>
  <td>forwards messages to a JMS queue</td>
</tr>
<tr>
  <td>caucho.log</td>
  <td>com.caucho.hemp.services.BamLogService</td>
  <td>logs messages to java.util.logging</td>
</tr>
<tr>
  <td>caucho.mail</td>
  <td>com.caucho.hemp.services.BamMailService</td>
  <td>sends an email with a summary of recent messages</td>
</tr>
</deftable>

<s2 title="JMS">

<p>The JMS service forwards BAM messages to a JMS queue, wrapping each
message in a JMS ObjectMessage.  Applications can use this BAM to JMS bridge
to queue messages from a Java client.</p>

<example title="Example: JMS configuration">
&lt;web-app xmlns="http://caucho.com/ns/resin">

  &lt;jms-connection-factory name="jms_cf" uri="resin:"/>
  &lt;jms-queue name="queue" uri="memory:"/>

  &lt;bam-service name="jms@localhost" uri="caucho.jms:">
    &lt;init>
      &lt;connection-factory>${jms_cf}&lt;/connection-factory>
      &lt;queue>${queue}&lt;/queue>
    &lt;/init>
  &lt;/bam-service>
  
&lt;/web-app>
</example>

</s2>

<s2 title="Logging">

<p>The logging service adds BAM messages to a java.util.logging Logger.
An application could use the logging service as a chat-room recording
or debugging service.</p>

<deftable title="caucho.log attributes">
<tr>
  <th>attribute</th>
  <th>description</th>
</tr>
<tr>
  <td>name</td>
  <td>logger name</td>
</tr>
<tr>
  <td>level</td>
  <td>logger level</td>
</tr>
</deftable>

<example title="Example: Log configuration">
&lt;web-app xmlns="http://caucho.com/ns/resin">

  &lt;bam-service name="log@localhost" uri="caucho.log:">
    &lt;init>
      &lt;name>com.foo.chat&lt;/name>
      &lt;level>info&lt;/level>
    &lt;/init>
  &lt;/bam-service>
  
&lt;/web-app>
</example>

</s2>

<s2 title="Mail">

<p>The mail service sends BAM messages to an email address.  This
can be used to notify any issues with an application that may need
administration.</p>

<deftable title="caucho.mail attributes">
<tr>
  <th>attribute</th>
  <th>description</th>
</tr>
<tr>
  <td>delay-time</td>
  <td>a pause interval to gather groups of messages before sending</td>
</tr>
<tr>
  <td>mail-session</td>
  <td>a javax.mail.Session object</td>
</tr>
<tr>
  <td>properties</td>
  <td>javamail properties</td>
</tr>
<tr>
  <td>subject</td>
  <td>the mail subject</td>
</tr>
<tr>
  <td>to</td>
  <td>a mail destination address</td>
</tr>
</deftable>

<example title="Example: Mail configuration">
&lt;web-app xmlns="http://caucho.com/ns/resin">

  &lt;bam-service name="mail@localhost" uri="caucho.mail:">
    &lt;init>
      &lt;to>bam@foo.com&lt;/name>
      &lt;subject>BAM Notification&lt;/subject>
      &lt;properties>
        mail.from=bamservice@foo.com
      &lt;/properties>
    &lt;/init>
  &lt;/bam-service>
  
&lt;/web-app>
</example>

</s2>
  
</s1>

<s1 title="API">

<s2 title="Client API">

<s3 title="BamClient">

<p><code>BamClient</code> is the primary client class for
local clients.  The <code>BamClient</code> will automatically create
a connection with the local broker.  Messages are sent using the
<code>BamConnection</code> methods.  Messages are received by
setting a BamStream handler.</p>

<def title="BamClient">
package com.caucho.bam;

public class BamClient implements BamConnection
{
  public BamClient();
  public BamClient(String uid, String password);
  public BamClient(String uid, String password, String resource);

  // BamConnection methods
  String getJid();
  ...
  void message(String to, Serializable value);
  ...
}
</def>

</s3>

<s3 title="BamConnection">

<p><code>BamConnection</code> is the primary client interface for both
local and remote clients.  Messages are sent using the
<code>BamConnection</code> methods.  Messages are received by
setting a BamStream handler.</p>

<p>An active <code>BamConnection</code> has an associated agent registered
with the broker.  The agent's jid is available with the <code>getJid()</code>
call.</p>

<p>For clients that need low-level access to the broker stream, e.g. to
implement an RPC/Query handler, <code>getBrokerStream()</code> returns
the underlying stream.</p>

<def title="BamConnection">
package com.caucho.bam;

public interface BamConnection
{
  String getJid();

  boolean isClosed();
  void close();
  
  void setStreamHandler(BamStream handler);

  void message(String to, Serializable value);

  Serializable queryGet(String to, Serializable query);
  Serializable querySet(String to, Serializable query);

  void queryGet(String to, Serializable query, BamQueryCallback callback);
  void querySet(String to, Serializable query, BamQueryCallback callback);

  void presence(Serializable data);
  void presence(String to, Serializable data);
  void presenceUnavailable(Serializable data);
  void presenceUnavailable(String to, Serializable data);
  void presenceProbe(String to, Serializable data);
  void presenceSubscribe(String to, Serializable data);
  void presenceSubscribed(String to, Serializable data);
  void presenceUnsubscribe(String to, Serializable data);
  void presenceUnsubscribed(String to, Serializable data);
  void presenceError(String to, Serializable data, BamError error);
  
  BamStream getBrokerStream();
}
</def>

</s3>

<s3 title="BamConnectionFactory">

<p>The <code>BamConnectionFactory</code> produces <code>BamConnection</code>
agents for client code.  Typically, the factory implementation will be
a <code>BamBroker</code>, although that is not required by the clients.</p>

<def title="BamConnectionFactory">
package com.caucho.bam;

public interface BamConnectionFactory
{
  BamConnection getConnection(String uid, String password);
  
  BamConnection getConnection(String uid, String password, String resourceId);
}
</def>

</s3>

<s3 title="BamQueryCallback">

<p><code>BamQueryCallback</code> is used for callback-style RPC.  When
the query response completes, the agent will call
the <code>BamQueryCallback</code> with the query's response.</p>

<def title="QueryCallback">
package com.caucho.bam;

public interface BamQueryCallback
{
  void onQueryResult(String to, String from, Serializable value);
  
  void onQueryError(String to, String from, Serializable value,
                    BamError error);
}
</def>
</s3>

</s2>

<s2 title="Remote Client API">

<p><code>HmtpClient</code> is the remote client API for Java clients.  Most
of the methods are extended from <code>BamConnection</code>.  The additional
method provide some control for connection and login.  Once the client
is logged in, applications will typically use
<code>BamConnection</code> methods to send messages and set handlers
to receive messages.</p>

<s3 title="HmtpClient">

<def title="HmtpClient">
package com.caucho.bam;

public class HmtpClient implements BamConnection
{
  public HmtpClient(String url);

  public void connect() throws IOException;

  public void login(String uid, String password);

  // BamConnection methods
  String getJid();

  boolean isClosed();
  void close();
  
  void setStreamHandler(BamStream handler);

  void message(String to, Serializable value);

  Serializable queryGet(String to, Serializable query);
  Serializable querySet(String to, Serializable query);

  void queryGet(String to, Serializable query, BamQueryCallback callback);
  void querySet(String to, Serializable query, BamQueryCallback callback);

  void presence(Serializable data);
  void presence(String to, Serializable data);
  void presenceUnavailable(Serializable data);
  void presenceUnavailable(String to, Serializable data);
  void presenceProbe(String to, Serializable data);
  void presenceSubscribe(String to, Serializable data);
  void presenceSubscribed(String to, Serializable data);
  void presenceUnsubscribe(String to, Serializable data);
  void presenceUnsubscribed(String to, Serializable data);
  void presenceError(String to, Serializable data, BamError error);
  
  BamStream getBrokerStream();
}
</def>
</s3>

</s2>

<s2 title="Protocol(Packet) API">

<s3 title="BamStream">

<p><code>BamStream</code> is the core streaming API for the broker and
its registered agents.  It is simply a combination of all the message,
query and presence packets.</p>

<p>Applications will implement <code>HmtpQueryStream</code> to receive
RPC calls and responses from the agent.  If the application implements
<code>sendQueryGet</code>, it must either send a <code>QueryResponse</code>
to the sender, or send a <code>QueryError</code> or return false from
the method.  Queries will always have a response or an error.</p>

<p>The presence methods implement the specialized subscription and
presence messages.  IM applications use presence messages
to announce availability to people in a buddy list (roster).</p>

<p>Publish/Subscribe applications can also use subscription packets
to subscribe and unsubscribe from the publishing service.</p>

<def title="BamStream">
package com.caucho.bam;

public interface BamStream {
{
  public void message(String to, String from, Serializable value);
  
  public void messageError(String to, String from, Serializable value,
                           BamError error);
			       
  boolean queryGet(long id, String to, String from, Serializable query);
  boolean querySet(long id, String to, String from, Serializable query);

  void queryResult(long id, String to, String from, Serializable value);
  void queryError(long id, String to, String from, Serializable query,
                  BamError error);
			       
  void presence(String to, String from, Serializable data);
  void presenceUnavailable(String to, String from, Serializable data);
  
  void presenceProbe(String to, String from, Serializable data);
  
  void presenceSubscribe(String to, String from, Serializable data);
  void presenceSubscribed(String to, String from, Serializable data);
  void presenceUnsubscribe(String to, String from, Serializable data);
  void presenceUnsubscribed(String to, String from, Serializable data);
  
  void presenceError(String to, String from, Serializable data,
                     BamError error);
}
</def>

</s3>

</s2>

<s2 title="Service APIs">

<s3 title="BamBroker">

<p><code>BamBroker</code> is the central player in the HMTP server.
It's responsible for routing messages between the agents, for any
forwarding to remote servers, and managing dynamic agents and services.
</p>

<p>For all that responsibility, the API is fairly simple.  The
<code>BamBroker</code> extends <code>BamConnectionFactory</code>,
enabling client agents, and allows custom <code>BamService</code>
services to be implemented.  Most importantly, it implements a
broker stream (<code>BamStream</code>) which serves as the destination
for all inbound messages.</p>

<def title="BamBroker">
package com.caucho.bam;

public interface BamBroker extends BamConnectionFactory
{
  BamStream getBrokerStream();

  void addService(BamService service);
  void removeService(BamService service);

  void addServiceManager(ServiceManager manager);
}
</def>

</s3>

<s3 title="BamService">

<p><code>BamService</code> represents a registered, persistent
service with a known jid address.  Typically the services will be
registered in a configuration file, although they can also be
created dynamically using the <code>BamServiceManager</code>.
Most applications will extend the <code>SimpleBamService</code>
instead of implementing <code>BamService</code> directly.</p>

<p>The key methods are <code>getJid</code> and <code>getAgentStream</code>.
The jid is used for registration with the <code>BamBroker</code> and
<code>getAgentStream</code> is used to receive any messages.</p>

<p>The additional methods are used for specialized applications like
instant messaging and multiuser-chat, to manage clients logging in.</p>



<def title="BamService">
package com.caucho.bam;

public interface BamService
{
  public String getJid();
  
  public BamStream getAgentStream();
  
  public boolean startAgent(String jid);
  public boolean stopAgent(String jid);

  public void onAgentStart(String jid);
  public void onAgentStop(String jid);

  public BamStream getAgentFilter(BamStream stream);
  public BamStream getBrokerFilter(BamStream stream);
}
</def>

</s3>

<s3 title="BamServiceManager">

<p><code>BamServiceManager</code> is a specialized manager for finding
persistent sessions.  In instant messaging, for example, the registered
users might be stored in a database.  When a message goes to
harry@host.com, the <code>BamServiceManager</code> will lookup the
appropriate user.</p>

<def title="BamServiceManager">
package com.caucho.bam;

public interface BamServiceManager
{
  public BamService findService(String jid);
}
</def>

</s3>

</s2>

</s1>

  </body>
</document>