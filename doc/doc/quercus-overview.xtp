<document>
  <header>
    <title>Quercus Overview and Getting Started Guide</title>
    <description><p>An overview and getting started guide for Quercus.</p></description>
  </header>

  <body>
    <localtoc/>


<s1 title="Introduction">

<p>Quercus implements the PHP 5 language in Java, including object
and exception support.  Quercus is a mixed interpreted/compiled implementation.
Long-running PHP scripts are compiled to Java for performance, while
short scripts, like <code>eval()</code> scripts are interpreted to
avoid compilation overhead.</p>

<p>Because Quercus is a Java implementation, it natively supports 16-bit
unicode strings and functions.  Quercus (in 3.1.0) supports the
new PHP 6 internationalization syntax, and the older unicode conversion
functions like <code>iconv</code>.  By default, Quercus uses UTF-8
encoding for PHP scripts and runtime unicode conversion.</p>

</s1>

<s1 name="existing" title="Running an existing PHP application on Quercus">

<p>In general, getting an application to run on Quercus is straightforward.  To
demonstrate this simple process, let's install
<a href="http://wordpress.org/">WordPress</a>.</p>
<p>Step 1.  Create the <code>${resin.home}/webapps/wordpress</code> directory.
That will be the base directory for the wordpress installation.  It will
correspond to a url like <code>http://localhost:8080/wordpress/</code>.
Extract the wordpress files in that directory.</p>

<p>Step 2.  Create the <code>${resin.home}/webapps/wordpress/WEB-INF</code> directory,
and add the resin-web.xml file below into that directory.  The resin-web.xml file
configures QuercusServlet, the Java servlet that interfaces to Quercus, to parse
<code>.php</code> files.  Since WordPress uses special ISO-8859-1 characters in
their PHP scripts, the script encoding is changed from the default UTF-8
to ISO-8859-1.  If you need to set ini values, see <a href="#php.ini">php.ini</a>.</p>

<example title="${resin.home}/webapps/ROOT/wordpress/WEB-INF/resin-web.xml">
&lt;web-app xmlns="http://caucho.com/ns/resin">
  &lt;servlet-mapping url-pattern="*.php"
                   servlet-class="com.caucho.quercus.servlet.QuercusServlet">
    &lt;init>
      &lt;script-encoding>iso-8859-1&lt;/script-encoding>
    &lt;/init>
  &lt;/servlet-mapping>
&lt;/web-app>
</example>

<p>Step 3.  If you have not already done so, download the
<a href="http://www.mysql.com/products/connector/j/">MySQL Connector/J JDBC driver</a>
into <code>${resin.home}/lib</code> to enable mysql database functions (See <a href="#databases">Using Databases</a>).</p>

<p>Step 4.  The configuration for Resin/Quercus is now complete.  Now you'll need to go through the application's installation routine.  For Wordpress, go to <a href="http://localhost:8080/wordpress/wp-admin/setup-config.php">http://localhost:8080/wordpress/wp-admin/setup-config.php</a> to start the installation.</p>

<p>That's it for Wordpress on Quercus.  If you are encountering issues with a certain application, please see <a>Resources</a> for assistance.</p>

<p>For a list of applications running successfully on Quercus, see <a href="quercus-list-of-applications.xtp">List of PHP Applications Running on Quercus</a>.</p>

</s1>

<s1 name="configuring" title="Configuring Quercus">

<s2 name="php.ini" title="php.ini">

<p>Individial PHP initialization values can be set in resin-web.xml.  For example, to set the settings for sending mail:</p>

<example title="WEB-INF/resin-web.xml">
&lt;web-app xmlns="http://caucho.com/ns/resin">
  &lt;servlet-mapping url-pattern="*.php"
                   servlet-class="com.caucho.quercus.servlet.QuercusServlet">
    &lt;init>
      &lt;php-ini>
        &lt;sendmail_from>my_email_address&lt;/sendmail_from>
        &lt;smtp_username>my_email_username&lt;/smtp_username>
        &lt;smtp_password>my_email_password&lt;/smtp_password>
      &lt;/php-ini>
    &lt;/init>
  &lt;/servlet-mapping>
&lt;/web-app>
</example>

<p>A PHP style ini file can also be specified:</p>

<example title="WEB-INF/resin-web.xml">
&lt;web-app xmlns="http://caucho.com/ns/resin">
  &lt;servlet-mapping url-pattern="*.php"
                   servlet-class="com.caucho.quercus.servlet.QuercusServlet">
    &lt;init>
      &lt;ini-file>WEB-INF/php.ini&lt;/ini-file>
    &lt;/init>
  &lt;/servlet-mapping>
&lt;/web-app>
</example>

</s2>

<s2 name="encoding" title="Character Encoding Issues">

<p>Because Quercus is 100% Java, Quercus has native support for Unicode and will, by default, parse PHP scripts in UTF-8.  This also means Quercus supports the new PHP 6 Unicode keywords like this Unicode typecast: <code>(unicode)"foo"</code>.  If a PHP application uses special ISO-8859-X characters (i.e. the copyright symbol, accented characters), Quercus will complain because the byte code of those characters are illegal in UTF-8.</p>

<p>To solution is to tell Quercus to parse PHP scripts using the correct character set (ISO-8859-1 for most applications).  For example, to tell Quercus to use ISO-8859-1, add <code>&lt;script-encoding></code> to the <code>init</code> tag of QuercusServlet:</p>

<example title="WEB-INF/resin-web.xml">
&lt;web-app xmlns="http://caucho.com/ns/resin">
  &lt;servlet-mapping url-pattern="*.php"
                   servlet-class="com.caucho.quercus.servlet.QuercusServlet">
    &lt;init>
      &lt;script-encoding><b>iso-8859-1</b>&lt;/script-encoding>
    &lt;/init>
  &lt;/servlet-mapping>
&lt;/web-app>
</example>

</s2>

<s2 name="garbage" title="Garbage Output On Browser">

<p>There are three encodings you need to worry about: script encoding, output
encoding, and runtime encoding.  By default, Quercus uses UTF-8 for all three.
Script encoding is for when your scripts are in an encoding other than
UTF-8.</p>

<p>Output encoding is the charset used to display output to the browser.
You can set it in your resin-web.xml:</p>

<example title="WEB-INF/resin-web.xml">
&lt;web-app xmlns="http://caucho.com/ns/resin">
  &lt;servlet-mapping url-pattern="*.php"
                  servlet-class="com.caucho.quercus.servlet.QuercusServlet">
    &lt;init>
      &lt;php-ini>
        &lt;unicode.output_encoding><b>MY_ENCODING</b>&lt;/unicode.output_encoding>
      &lt;/php-ini>
    &lt;/init>
  &lt;/servlet-mapping>
&lt;/web-app>
</example>

<p>There is another encoding that you need to know about.  It is the
unicode.runtime_encoding and it defaults to UTF-8.  It is a PHP 6 directive
that tells Quercus what encoding to assume a binary string is in when
doing implicit conversions to Unicode.  You would set runtime encoding in the
same way as you would for output encoding.</p>

<p>In PHP 6, there are two types of strings, Unicode and binary.  A binary
string is a string where the data is binary, the encoding is unknown, or the
encoding is not Unicode (UTF-16).  If you ever use a function that will likely
return a binary string, then you probably need to set unicode.runtime_encoding.
Quercus may convert your binary string to Unicode and then to your output
encoding for output to the browser.  If your runtime encoding is wrong, then
you would see garbage in your browser.</p>

</s2>

<s2 name="compiling" title="Compiling PHP Scripts for Increased Performance">

<p>Quercus will automatically compile PHP scripts into Java classes for better performance.  This is available only in Resin Professional.</p>

<p>The default behaviour in Resin Professional is to execute the PHP script in
interpreted mode, and to compile the script in the background.  When the
compiled version is ready, it is used instead of the interpreted version.  To
force compilation, use the <code>&lt;compile></code> tag within the
<code>&lt;init></code> tag:</p>

<example title="WEB-INF/resin-web.xml">
&lt;web-app xmlns="http://caucho.com/ns/resin">
  &lt;servlet-mapping url-pattern="*.php"
                   servlet-class="com.caucho.quercus.servlet.QuercusServlet">
    &lt;init>
      <b>&lt;compile>true&lt;/compile></b>
    &lt;/init>
  &lt;/servlet-mapping>
&lt;/web-app>
</example>

</s2>

</s1>

<s1 name="databases" title="Using Databases">

<p>JDBC drivers are required to use databases in Quercus.  There are JDBC
drivers for MySQL, Oracle, SQLite, and many other database engines.  The
desired JDBC driver should be downloaded into Resin's <code>${resin.home}/lib</code>
directory.  Resin will automatically load jars in the <code>lib</code>
directory upon startup.</p>

<table>
<tr><th>Database type</th>
    <th>URL for download</th>
    <th>Typical jar name</th></tr>
<tr><td>MySQL</td>
    <td><a href="http://dev.mysql.com/downloads/connector/j">http://dev.mysql.com/downloads/connector/j</a></td>
    <td>${resin.home}/lib/mysql-connector-java-3.1.11-bin.jar</td></tr>
<tr><td>PostgreSQL</td>
    <td><a href="http://jdbc.postgresql.org/download.html">http://jdbc.postgresql.org/download.html</a></td>
    <td>${resin.home}/lib/postgresql-8.1-407.jdbc3.jar</td></tr>
<tr><td>Oracle</td>
    <td><a href="http://www.oracle.com/technology/software/tech/java/sqlj_jdbc">http://www.oracle.com/technology/software/tech/java/sqlj_jdbc</a></td>
    <td>${resin.home}/ojdbc14.jar</td></tr>

</table>

<p>The database support in Quercus supports robust database connection
pooling since Quercus runs in Resin, a fast Java application server.
All PHP database access automatically uses JDBC-pooled connections.  PHP
code does not need changing to take advantage of this capability.</p>

<p>The PHP database apis supported include PDO (portable database objects),
mysql, mysql improved, postgres and oracle.  Any JDBC-compliant database
is available to PHP scripts using PDO.</p>

<example title="PDO access to JNDI-configured databases">
&lt;php

$db = new PDO("java:comp/env/jdbc/my-database");

...
?>
</example>

<s2 name="datasource" title="JNDI DataSource">

<p>If a database with JNDI name <code>jdbc/myDatabase</code> is defined in
resin.conf, (see <a href="config-database.xtp">Database Configuration</a>),
Quercus can do a JNDI lookup for the database when database functions are
called.  Thus, database connection parameters like user name can be omitted
within PHP scripts.  This allows easier maintenance and enables Java and PHP
database settings to be centrally located in resin.conf.</p>

<p>Scripts can use the jndi name directly:</p>

<example>
&lt;?php

  // standard PHP
  //mysql_connect($host, $username, $password, $dbname);

  // using JNDI lookup
  mysql_connect("java:comp/env/jdbc/myDatabaseName");

?>
</example>

<p>
Or a <code>&lt;database</code> configuration can be provided to QuercusServlet,
which cases that DataSource to be used for all database connections regardless
of what the script provides in it's connect function call:
</p>

<example title="WEB-INF/resin-web.xml">
&lt;web-app xmlns="http://caucho.com/ns/resin">
  &lt;servlet-mapping url-pattern="*.php"
                   servlet-class="com.caucho.quercus.servlet.QuercusServlet">
    &lt;init>
      <b>&lt;database>java:comp/env/jdbc/myDatabaseName&lt;/compile></b>
    &lt;/init>
  &lt;/servlet-mapping>
&lt;/web-app>
</example>

</s2>

</s1>

<s1 name="module" title="Adding PHP functions by creating a Quercus module">

<p>The core PHP functions are implemented inside Quercus modules.  Quercus modules are the Java equivalent of PHP modules.  </p>

<p>All Quercus modules need to implement AbstractQuercusModule.  Functions defined in your modules are callable from within PHP script by using just the function name.  Function names need to be distinct in order to prevent name collisions, though Quercus does support function overloading (for Java functions only).</p>

<p>A typical Quercus module looks like:</p>

<example title="WEB-INF/classes/example/HelloModule.java">
package example;

import com.caucho.quercus.env.Env;
import com.caucho.quercus.module.AbstractQuercusModule;

public class HelloModule extends AbstractQuercusModule
{
  /**
   * @param env provides Quercus environment resources.
   * @param str
   */
  public void HeLLo_TeST(Env env, String str)
  {
    // 'echos' the string
    env.println("hello " + str);
  }
}
</example>

<example title="example.php">
&lt;?php

  // PHP 5 is case-insensitive
  // just prints "hello me" to the browser.
  hello_test("me");

?>
</example>

<p>For a tutorial on how to implement your own Quercus module, see the <a href="../examples/quercus-module/index.xtp">Quercus module tutorial</a>.</p>

</s1>

<s1 name="pojo" title="Using Plain Old Java Objects (POJO) in PHP Scripts">

<p>
You do not need to create a Quercus module in order to use your Java code in a
PHP script.  Quercus provides the <code>java()</code> function to call
constructors of Java objects and <code>java_class()</code> to obtain the Java
class without calling the constructor.  Quercus also extends the PHP language
with an <code>import</code> statement.
</p>

<p>For more information see
<a href="quercus-java-integration.xtp">Java Integration</a>.</p>

<example title="example.php">
&lt;?php

  // Quercus specific import statement
  import java.util.Date;

  $date = new Date(123456789);

  $list = java("java.util.ArrayList");

?>
</example>


</s1>

<s1 name="marshaling" title="Java Function Arguments/Return Marshaling">

<p>Quercus does marshaling to and from PHP values and Java objects.  If a Java function requires a String, Quercus will automatically convert the internal Quercus StringValue to a String.  If a Java function returns an <code>int</code>, Quercus will create a Quercus LongValue for it.</p>

<p>For other Java Objects like <code>java.util.Data</code> that are returned to PHP, Quercus puts them into wrappers to expose their public methods and members to the PHP script.  Java Collection, List, and Map instances have the additional ability to be used within a PHP script like any other PHP array.</p>

<p>For more information, see <a href="quercus-java-integration.xtp">Java Integration</a>.</p>

</s1>

<s1 name="quercus_functions" title="Quercus specific functions">

<p>Quercus has several Quercus specific PHP functions for debugging and Java integration (JNDI, JMS, and JMX).  For more information, see <a href="quercus-resin-module.xtp">Resin PHP Functions</a>.</p>

<s2 name="debugging_functions" title="Debugging Functions">

<dl>
<dt>resin_var_dump($a)</dt>
<dd>dumps the argument to standard out</dd>
<dt>resin_call_stack()</dt>
<dd>returns an array containing the PHP function call stack.</dd>
<dt>resin_debug($a)</dt>
<dd>logs the argument into Resin's log at the INFO level</dd>
<dt>resin_thread_dump()</dt>
<dd>dumps the Java stack to standard out</dd>
</dl>

</s2>

<s2 name="jndi" title="JNDI">

<p><code>jndi_lookup()</code> is a Quercus specific function that can be called to retrieve JNDI objects.  It is useful in a <a href="soa.xtp">SOA (Service Oriented Architecture)</a> system to locate a Java service.</p>

</s2>

</s1>

<s1 name="diff" title="Differences from PHP 6">

<p>Quercus implements PHP 5 but supports most of PHP 6 language features that
are available in the PHP 6 preview distribution.  Differences from PHP 6
are:</p>

<ol>

<li>Unicode support cannot be turned off.</li>

<li>For performance considerations, Unicode string indexing is done by Unicode
code units.  A Unicode code unit is equivalent to a Java <code>char</code>
primitive.  In PHP 6, it is done by code points.  A code point consists of 1 or
2 code units.  Quercus uses code units because determining code point
boundaries takes a lot of resources.</li>

</ol>

</s1>

<s1 name="module_highlights" title="Module highlights">
<s2 name="standard_modules" title="Standard modules">

<p>Quercus implements the standard PHP libraries (arrays, strings,
date, regexp, etc).  It also supports extension libraries like zip and
zlib for compression, mcrypt for encryption, mail (implemented with
JavaMail), and bcmath for large numbers.</p>

</s2>

<s2 name="apc_module" title="APC (object caching)">

<p>For PHP object caching, Quercus implements the APC module.  PHP applications
can use the APC functions to save PHP objects without resorting to
serialization and database persistence.  Because Quercus runs in Resin,
a Java web server, the saved objects are quickly available to any
thread running PHP.  In other words, unlike Apache which makes sharing across
different PHP processes difficult, Quercus can just store a singleton cache
of the APC-cached objects.</p>

<p>Because Quercus compiles PHP to Java code, PHP scripts get the opcode
caching of APC for free.  At this time, performance of Quercus is roughtly
comparable with performance of mod_php with APC, i.e. it is significantly
faster (3-5 times) than mod_php running by itself.</p>

</s2>

<s2 name="gd_module" title="Image support ('gd')">

<p>Quercus provides the image module, so users can use image manipulation
functions like watermarking and thumbnail generation in
any PHP script on Quercus.  .jpg, .png, and .gif files are currently
supported.  Java users will also find these libraries convenient.</p>

</s2>

<s2 name="pdflib_module" title="PDF generation (PDFlib api)">

<p>PDF generation in Quercus follows the PDFlib API.  Since the Quercus
PDF implementation is a new implementation in Java, no special downloads
are needed to use PDF.</p>

</s2>

<s2 name="json_module" title="AJAX (JSON)">

<p>Quercus also includes the JSON module for encoding and decoding
AJAX-style requests.  The JSON modules is an excellent example of
the benefits of writing modules in Java.  Because Java supports
garbage collection and protects from pointer overruns, the JSON module
implementation is straightforward and reliable, without having to worry
about all the possible memory problem in a C library.</p>

</s2>

<s2 name="gettext_module" title="Gettext (localization)">

<p>Quercus supports the gettext API and .po and .mo files.
gettext is a portable API for localization, i.e. translation of program
messages.  In the future, the Quercus gettext implementation will
support Java message bundles so Java applications using PHP can use
standard Java localization techniques.</p>

</s2>
</s1>

<s1 name="resources" title="Resources">

<ul>
<li><a href="http://forum.caucho.com">Caucho Forums, including a Quercus forum</a></li>
<li><a href="http://bugs.caucho.com">Caucho Bug Tracker</a></li>
<li><a href="http://maillist.caucho.com/mailman/listinfo">Caucho Mailing Lists</a></li>
</ul>

</s1>

  </body>
</document>
