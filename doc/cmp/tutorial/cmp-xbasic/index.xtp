<document>
  <header>
    <product>resin-ee</product>
    <title>Basic CMP with XDoclet</title>
    <description>
       This example duplicates the Basic CMP demo, but uses XDoclet-style tags.
    </description>
    <type>tutorial</type>
    <tutorial-startpage>xbasic</tutorial-startpage>
  </header>

  <body>
    <summary/>

<p>Resin-EE manages tables in a relational database using a Java
bean interface.  Each database table corresponds to a single "entity bean".  
(Since Resin-EE uses the EJB specification, most of its jargon
comes from EJB.)  By creating an entity bean with container managed
persistence, you let Resin-EE generate the SQL to load, store, and
cache entity beans from the database.  Avoiding SQL is an advantage in
itself, but the primary advantage is the increased flexiblity of your
application code.  Maintenance and code-refactoring can focus on the
beans instead of changing lots of SQL statements in the program.</p>

<p>In this example, Hogwarts School of Witchcraft and Wizardry uses
Resin-EE to manage its list of courses offered for the term.  Each
course has a name and a teacher for the course.  The example has been
simplified as much as possible; following examples show how to
<a href="cmp|tutorial/cmp-xfind/index">query the database</a> and <a href="cmp|tutorial/cmp-xcreate/index">create and remove</a> database entries.</p>

<s1 title="Files in this tutorial">
<deftable>
<tr><td><viewfile-link file="WEB-INF/classes/example/CourseBean.java"/>
    </td><td>The main bean implementation, including the xdoclet tags.
</td></tr><tr><td><viewfile-link file="WEB-INF/web.xml"/>
    </td><td>Configures the environment
</td></tr><tr><td><viewfile-link file="WEB-INF/classes/example/CourseServlet.java"/>
    </td><td>The demo servlet
</td></tr><tr><td><viewfile-link file="WEB-INF/classes/example/InitServlet.java"/>
    </td><td>Servlet initializing the database
</td></tr></deftable>
</s1>

<s1 title="Database Schema">

<p>The database table uses the course name as the primary key.  Each bean
in Resin-EE needs its own primary key.  It is possible to let the
database generate primary keys, e.g. automatically generated integers.
Since this example only reads data from
the table, we'll prepopulate it with the courses.</p>

<p>Each table maps to a single object, using the
<code>abstract-schema-name</code> and <code>sql-table</code>
in the ejb.xml.  If you look at the
distribution's database schema (in cmp/WEB-INF/sql/default.sql),
you'll notice that each example has its own table, e.g. basic_courses
and find_courses, even though the examples often share the same
table.  Generally a Resin-EE bean has complete control over a database
table.  Because it controls the table, the bean can cache data without
worrying that the database will change without its knowledge.</p>

<p>Database columns map to accessor methods in the bean, using standard
rules.  The <code>id</code> field maps to <code>getId</code>.
The <code>instructor</code> column maps to <code>getInstructor</code> and
<code>setInstructor</code>.</p>

<example title="course.sql">
CREATE TABLE basic_courses (
  id VARCHAR(250) NOT NULL,
  teacher VARCHAR(250),

  PRIMARY KEY(id)
);

INSERT INTO basic_courses VALUES('Potions', 'Severus Snape');
INSERT INTO basic_courses VALUES('Transfiguration', 'Minerva McGonagall');
</example>

</s1>

<s1 title="Implementation Classes">

<p>Each database table corresponds to a single "entity bean".  
Since Resin-EE uses the EJB specification, most of its the jargon
comes from EJB.  The developer needs to write three classes for each
entity bean:</p>

<ul>
<li>The <var>local home</var> factory interface for clients to find
and create beans.
</li><li>The <var>local</var> interface for clients to use.
</li><li>The <var>implementation</var> bean to write business methods.
</li></ul>

<p>Why three classes? The interfaces add code clarity for the
developer and flexibility for Resin-EE.  It's conceptually cleaner
to separate the interfaces of the bean from its implementation.  It's
also cleaner to separate the factory pattern interface from the
object interface.  Separating the classes gives Resin-EE the
flexibility to add its caching and transaction code without
requiring any client changes.</p>

<p>Resin-EE focuses on <var>local interfaces</var>, as
opposed to the <var>remote interfaces</var> of traditional EJB.  Local
interfaces are used in a single servlet web-application and avoid the
complexities of distributed computing.  In addition, local interfaces
are faster since they can use normal pass-by-reference Java calls.
In this way, Resin-EE turns EJB on its head.  EJB is a distributed
computing interface with support for object-managed databases.
Resin-EE provides an object view to relational database, and has
support for distributed calls for those rare applications which
really need it.</p>

<s2 title="Bean Implementation">

<p>Since Resin-EE provides most of the implementation code, the
Bean implementation just has a bunch of abstract methods.  More
complicated beans will add business methods to the entity bean's
implementation class.  Because business methods run in a single
transaction context, you can use them to ensure database consistency
without having to write any transaction code yourself.</p>

<p>The field accessors are abstract since Resin-EE will generate the
code to call JDBC and execute the SQL queries.  Like all entity beans,
clients never use a CourseBean directly, but always work through a
stub generated by Resin-EE.</p>

<p>The AbstractEntityBean class is a convenience class in Resin-EE.
Each entity bean must implement the EntityBean interface which has
several methods.  Since most applications don't need to customize the
methods, AbstractEntityBean simplifies the implementation code.</p>

<example title="CourseBean.java">
package example;

/**
 * @ejb.bean name="xbasic_course" view-type="local" type="CMP"
 *           schema="courses" primkey-field="id"
 * @ejb.persistence table-name="xbasic_courses"
 * @ejb.pk class="java.lang.String"
 * @ejb.home generate="local" local-class="example.CourseHome"
 * @ejb.interface generate="local" local-class="example.Course"
 */
public abstract class CourseBean
  extends com.caucho.ejb.AbstractEntityBean {
  /**
   * @ejb.interface-method
   * @ejb.persistence column-name="id"
   * @ejb.pk-field
   */
  public abstract String getId();
  /**
   * @ejb.interface-method
   * @ejb.persistence column-name="teacher"
   */
  public abstract String getInstructor();
  /**
   * @ejb.interface-method
   * @ejb.persistence column-name="teacher"
   */
  public abstract void setInstructor(String val);
}
</example>

<p>The number of XDoclet tags may appear daunting at first, but most
of them are cut and pasted from one bean to the next.</p>

<deftable title="XDoclet tags">
<tr><th>Tag</th><th>Attribute</th><th>Meaning
</th></tr><tr><td>@ejb.bean</td><td>&#160;</td><td>configuration applicable to the entire bean
</td></tr><tr><td>&#160;</td><td>name</td><td>The EJB and JNDI name for the bean
</td></tr><tr><td>&#160;</td><td>view-type</td><td>"local" for local CMP beans
</td></tr><tr><td>&#160;</td><td>type</td><td>"CMP" for CMP beans, "BMP" for BMP beans
</td></tr><tr><td>&#160;</td><td>schema</td><td>The abstract schema name for the bean, i.e. the
</td></tr><tr><td>&#160;</td><td>primkey-field</td><td>The primary key field for the bean
</td></tr><tr><td>@ejb.persistence</td><td>&#160;</td><td>persistence (SQL) configuration.  For methods, marks the method as persistent
</td></tr><tr><td>&#160;</td><td>table-name</td><td>The actual database table for the bean
</td></tr><tr><td>&#160;</td><td>column-name</td><td>The actual column for the field
</td></tr><tr><td>@ejb.pk</td><td>&#160;</td><td>configuration for the primary key
</td></tr><tr><td>&#160;</td><td>class</td><td>The class of the primary key
</td></tr><tr><td>@ejb.home</td><td>&#160;</td><td>configuration for the home interface
</td></tr><tr><td>&#160;</td><td>generate</td><td>Which interfaces to generate: "local,remote"
</td></tr><tr><td>&#160;</td><td>local-class</td><td>The class name of the local home interface
</td></tr><tr><td>@ejb.interface</td><td>&#160;</td><td>configuration for the object interface
</td></tr><tr><td>&#160;</td><td>generate</td><td>Which interfaces to generate: "local,remote"
</td></tr><tr><td>&#160;</td><td>local-class</td><td>The class name of the local object interface
</td></tr><tr><td>@ejb.interface-method</td><td>&#160;</td><td>exposes the method as an interface
</td></tr><tr><td>@ejb.pk-field</td><td>&#160;</td><td>marks the method as the primary key
</td></tr></deftable>

</s2>

<p>With Resin-EJB, all the Java source can be dropped in WEB-INF/classes.
Resin will automatically compile any changes and regenerate the persistence
classes, stubs and skeletons.</p>

</s1>

<s1 title="Local Home Interface">

<p>The home interface is reponsible for factory pattern methods:
finding existing objects and creating new objects.  At minimum, each
home interface lets you find an object using its primary key.
The <code>findByPrimaryKey</code> method exists for any entity bean.</p>

<p>The XDoclet code automatically generates the local home
interface based on the doclet tags from the CourseBean class.  In
this example, the only generated method is <code>findByPrimaryKey</code>.
The generated <code>CourseHome</code> looks like the following:</p>

<example title="CourseHome.java">
package example;

import javax.ejb.*;

public interface CourseHome extends EJBLocalHome {
  Course findByPrimaryKey(String name)
    throws FinderException;
}
</example>

<p>Find methods always return the local interface for the bean or a
collection of local interfaces and always throw the FinderException.</p>

<p>Each home interface must extend the EJBLocalHome interface.  Local
home interfaces can only be used same web-application as the server.
This makes it a perfect solution for servlet-based database applications.</p>

</s1>

<s1 title="Local Interface">

<p>The local interface, <code>Course</code>, is where all the action is.
<code>CourseBean</code> exposed three methods to the local interface
using the @ejb.interface-method tag: <code>getId</code>, <code>getInstructor</code>
and <code>setInstructor</code>.  Local interfaces always extend
<code>EJBLocalObject</code>.</p>

<p>The generated <code>Course</code> looks like the following:</p>

<example title="Course.java">
package example;

import javax.ejb.*;

public interface Course extends EJBLocalObject {
  String getId();

  String getInstructor();
  void setInstructor(String instructor);
}
</example>

<p>Clients always use the home interface to get the local interface.
The Resin-EE generated stub (the class implementing the interface)
will call the underlying implementation bean and SQL, adding
transaction management as necessary.</p>

</s1>

<s1 title="Deployment Descriptor">

<p>The deployment descriptor configures the entity bean.  It
specifies the home, local, and implementation classes.</p>

<p>The *.ejb file is generated automatically by XDoclet.  The
<a href="cmp|tutorial/cmp-basic/index">basic tutorial</a> gives
a fuller description.</p>

</s1>

<s1 title="Resin Configuration">

<p>Now that we've built the bean, we need to
attach it to Resin.  The entity bean is deployed using
the <code>EJBServer</code> resource.</p>

<example title="WEB-INF/web.xml">
&lt;web-app&gt;
  &lt;!-- database configuration --&gt;
  &lt;database&gt;
    &lt;name&gt;jdbc/test&lt;/name&gt;
    &lt;driver-class&gt;oracle.jdbc.pool.OracleConnectionPoolDataSource&lt;/driver-class&gt;
    &lt;driver-url&gt;jdbc:oracle:thin:@gryffindor:1521:hogwarts&lt;/driver-url&gt;
    &lt;xa/&gt;
  &lt;/database&gt;

  &lt;!-- server configuration --&gt;
  &lt;ejb-server name="cmp"&gt;
    &lt;config-directory&gt;WEB-INF&lt;/config-directory&gt;
    &lt;data-source&gt;jdbc/test&lt;/data-source&gt;
    &lt;create-database-schema/&gt;
  &lt;/ejb-server&gt;
&lt;/web-app&gt;
</example>

<deftable>
<tr><th>EJBServer configuration</th><th>meaning
</th></tr><tr><td>ejb-server</td><td>configures the ejb server
</td></tr><tr><td>name</td><td>The JNDI name where the EJBs will be stored
</td></tr><tr><td>config-directory</td><td>Directory of the *.ejb files
</td></tr><tr><td>data-source</td><td>JNDI name of the database
</td></tr><tr><td>create-database-schema</td><td>flag telling Resin-EE to automatically create the schema if missing
</td></tr><tr><th>JDBC tag</th><th>meaning
</th></tr><tr><td>database</td><td>configures the database
</td></tr><tr><td>name</td><td>The JNDI name where the database will be stored
</td></tr><tr><td>driver-class</td><td>The class of the database driver
</td></tr><tr><td>driver-url</td><td>JDBC URL for the driver
</td></tr><tr><td>xa</td><td>flag telling that the database must be transaction-aware
</td></tr></deftable>

<s2 title="Transaction DataSource">

<p>The database needs to be configured with &lt;xa/&gt; to enable
transactions.  It's important for CMP to be run with transactions enabled
for consistency.  So if there's a
conflict or some other need to roll back the transaction, you need
&lt;xa/&gt; and the database's transaction ability to
protect the database consistency.</p>

</s2>

</s1>

<s1 title="Client Servlet">

<p>Now that we've defined the EJB, we should go ahead and use it.
Because we haven't defined any method to find all the courses, we
need to know them beforehand.</p>

<p>Because everything is defined in the web.xml, we just need to know
that the <code>CourseHome</code> is at <code>java:comp/env/cmp/house</code>.  So servlet
code can be completely independent of the server deployment.  Because
the JNDI lookup is relatively slow, applications generally lookup the
Home interface in the <code>init()</code> interface and store it as a
servlet variable.</p>

<example title="CourseServlet.java">
package example;

import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
import javax.naming.*;
import javax.ejb.*;

public class CourseServlet extends HttpServlet {
  // cache the home interface so the JNDI only happens once
  private CourseHome _home = null;

  public void init()
    throws ServletException
  {
    try {
      // The JNDI context containing local EJBs
      Context cmp = (Context) new InitialContext().lookup("java:comp/env/cmp");

      // Get the house stub
      _home = (CourseHome) cmp.lookup("basic_CourseBean");
    } catch (NamingException e) {
      throw new ServletException(e);
    }
  }

  public void doGet(HttpServletRequest req, HttpServletResponse res)
    throws IOException, ServletException
  {
    PrintWriter out = res.getWriter();

    res.setContentType("text/html");

    out.println("&lt;h3&gt;Course Details&lt;/h3&gt;");

    String []courses = new String[] { "Potions", "Transfiguration" };

    try {
      for (int i = 0; i &lt; courses.length; i++) {
        // Find the course using the home interface
        Course course = home.findByPrimaryKey(courses[i]);

        out.println("course: " + course.getCourseId() + "&lt;br&gt;");
        out.println("instructor: " + course.getInstructor() + "&lt;br&gt;");
        out.println("&lt;br&gt;");
      }
    }
    catch (FinderException e) {
      throw new ServletException(e);
    }
  }
}
</example>
<results>
<h3>Course Details</h3>
course: Potions
instructor: Severus Snape

course: Transfiguration
instructor: Minerva McGonagall
</results>

</s1>

<s1 title="Conclusion">

<p>The core of Resin-EE's database management is its management of a
single table.  Much of the work underlying the database management is
hidden from the applicaton.  Transaction management and caching happen
automatically.  For example, once the course has been loaded from the
database, Resin-EE does not need to query the database again until
the course changes.  So read-only requests, the most common, can avoid
all database traffic.</p>

<p>More complicated applications build on the single table
management.  The following examples add more realistic features to
this example: using queries to <a href="cmp|tutorial/cmp-find/index">find all
courses</a> and <a href="cmp|tutorial/cmp-xcreate/index">creating</a> new database rows.
</p>

</s1>
  </body>
</document>