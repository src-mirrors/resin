<document>
  <header>
    <product>resin-ee</product>
    <resin-2.0>$ee/ejb-ref/resin-ejb-config.xtp</resin-2.0>
    <title>Resin EJB Configuration</title>
  </header>

  <body>
<summary/>

<s1 title="Configuration">

<s2 title="abstract-sql-type" type="defun">
<p>An abstract SQL type to be used when automatically creating a table for
the entity bean.  Resin-CMP will use the abstract-sql-type and the
database driver type to determine the actual type used to create
the database table.</p>
</s2>

<s2 title="cache-size" version="Resin-CMP 1.0.5" type="defun">
<p>Defines the size of the entity cache.</p>
<p>The default cache-size is 8192.</p>
</s2>

<s2 title="cache-timeout" version="Resin-CMP 1.0.5" type="defun">
<p>Defines how long a loaded bean will remain loaded.
As long as a cached CMP bean is loaded, it doesn't need to query the
database, saving time and database load.</p>

<p>The default value is 5 seconds.</p>
</s2>

<s2 title="cmp-field" type="defun">
<p>Defines one of the bean's fields to be managed by Resin-CMP.
Since Resin-CMP will introspect the cmp-fields from the classes, the
cmp-field is optional.</p>

<p>cmp-fields are either Java primitives or serializable types, i.e.
values in a database table.  Relations between beans are configured
in the <a href="relations.xtp">relations</a> section.</p>

<deftable>
<tr><th>Element</th><th>Meaning
</th></tr><tr><td>field-name</td><td>the field name
</td></tr><tr><td>sql-column</td><td>the SQL column name
</td></tr><tr><td>sql-type</td><td>the SQL type
</td></tr></deftable>

<p>The SQL name is generated automatically from the cmp-field (or
the getter method.)  The getter method <var>getMyField</var> corresponds to
the cmp-field <var>myField</var> and the SQL column <var>my_field</var>.  An
EJB-QL query, always uses the cmp-field name, e.g. <var>myField</var>.</p>

<p>The cmp-field can specify the SQL column name using sql-column.</p>

<example title="student.ejb">
  &lt;entity&gt;
    &lt;abstract-schema-name&gt;students&lt;/abstract-schema-name&gt;
    &lt;sql-table&gt;student_table&lt;/sql-table&gt;
    ...
    &lt;cmp-field&gt;
      &lt;field-name&gt;id&lt;/field-name&gt;
      &lt;sql-column&gt;student_id&lt;/sql-column&gt;
    &lt;/cmp-field&gt;
    &lt;cmp-field&gt;
      &lt;field-name&gt;name&lt;/field-name&gt;
      &lt;sql-column&gt;user_name&lt;/sql-column&gt;
    &lt;/cmp-field&gt;
    ...
  &lt;/entity&gt;
</example>

<p>The above descriptor would expect the following schema:</p>

<example title="student.sql">
CREATE TABLE student_table (
  student_id INTEGER AUTO_INCREMENT,
  user_name VARCHAR(255),

  PRIMARY KEY(student_id)
);
</example>

</s2>

<s2 title="data-source" type="defun">
<p>Specifies the database JNDI name for the DataSource.  If unspecified,
it defaults to the value in EJBServer.</p>
</s2>

<s2 title="field-name" type="defun">
<p>Specifies the field name for a cmp-field definition.  The field-name
is the bean name for the Java getter method.  So the field-name for <code>getFoo</code> is <var>foo</var>.</p>
</s2>

<s2 title="method" type="defun">
<p>Configuration for a business method.  Each business method is
specified by a &lt;signature&gt;.  The signature syntax is the
same as Java function syntax without the return type.</p>

<p>The arguments are optional and the method name can be "*".
The best matching method will be used.  Methods which match a
method with specified args is better than a method with only a method name.
And both are better than the default match.</p>

<example title="Configure most methods as read-only">
&lt;method signature="*"&gt;
  &lt;resin-isolation&gt;read-only&lt;/resin-isolation&gt;
&lt;/method&gt;

&lt;method signature="writeMethod(String)"&gt;
  &lt;resin-isolation&gt;database&lt;/resin-isolation&gt;
&lt;/method&gt;
</example>

<def>
method ::= signature, resin-isolation?
</def>

</s2>

<s2 title="query-function" type="defun">
<p>Adds a new function to the EJB-QL language.
The query-function must specify the function signature in Java syntax.
The following types are allowed: int, double, boolean, String, Date and
any.</p>

<p>An optional <var>sql</var> attribute lets you provide custom functions.</p>

<example title="Adding MD5">
&lt;query-function&gt;
  &lt;signature&gt;String MD5(String)&lt;/signature&gt;
&lt;/query-function&gt;
</example>

<example title="Adding an add function">
&lt;query-function&gt;
  &lt;signature&gt;int add(int, int)&lt;/signature&gt;
  &lt;sql&gt;((?1) + (?2))&lt;/signature&gt;
&lt;/query-function&gt;
</example>

<def>
query-function = element query-function {
  signature, sql?
}
</def>

</s2>

<s2 title="query-loads-bean" type="defun">
<p>If true, an <code>ejbSelect</code> or <code>find</code> query will
load the beans in the query's select.  If false, the query will
only load the primary key and lazily load the bean when it's referenced.</p>

<p>Normally, setting this true will give better performance.</p>

<example title="Default all querys to lazy load">
&lt;method&gt;
  &lt;signature&gt;*&lt;/signature&gt;
  &lt;query-loads-bean&gt;false&lt;/query-loads-bean&gt;
&lt;/method&gt;
</example>

<p><b>Default:</b> true by default.</p>
</s2>

<s2 title="read-only" type="defun">
<p>Configures a bean as read-only.
Read-only entity bean values can be cached between calls even
in "update" transactions .  The cache time is configured with cache-time.
</p>
</s2>

<s2 title="resin-ejb" type="defun">
<p>Top-level configuration for the Resin-specific configuration.</p>

<def>
resin-ejb ::= enterprise-beans
</def>
</s2>

<s2 title="resin-isolation" type="defun">
<p>Configures the isolation level for a method.  Each method is
classified with either <var>read-only</var> or <var>database</var> isolation.
<var>read-only</var> methods only read database from the database.
<var>database</var> methods read and write to the database.</p>

<p>By telling Resin which methods are read-only, Resin can effectively
cache read values and reduce the database load.</p>

<p>For methods defined by EJB as write methods, Resin will ignore
the read-only value.  <code>setXXX</code>, <code>create</code>, and <code>remove</code>
methods always have <var>database</var> or stronger isolation.</p>

<p>For methods defined by EJB as read methods, Resin
will use <var>read-only</var> as a default.</p>

<p><b>Default:</b> the default value is <var>database</var></p>
</s2>

<s2 title="signature" type="defun">
<p>Speficies a function signature, i.e. a method declaration, in Java
syntax.
In the case of &lt;query-function&gt;, &lt;signature&gt; specifies the
name and types for a new EJB-QL function.
</p>
</s2>

<s2 title="sql-column" type="defun">
<p>The SQL column name for a field or relation.  If is unspecified,
it defaults to the field name.  The value of sql-column is
never used in the EJB queries.  It's just used during SQL generation.</p>

<p>For relations where the target bean has a compound primary key,
the sql-column can specify a <var>references</var> attribute to distinguish
which part of the primary key to configure.</p>

<example title="Specifying a cmp-field">
&lt;entity&gt;
  &lt;ejb-name&gt;students&lt;/ejb-name&gt;
  ...
  &lt;cmp-field&gt;
    &lt;field-name&gt;id&lt;/field-name&gt;
    &lt;sql-column&gt;student_id&lt;/sql-column&gt;
  &lt;/cmp-field&gt;
&lt;/entity&gt;
</example>

<example title="A pointer to a compound-key bean">
&lt;cmr-field&gt;
  &lt;cmr-field-name&gt;child&lt;/cmr-field-name&gt;
  &lt;sql-column references='parent'&gt;test_parent&lt;/sql-column&gt;
  &lt;sql-column references='name'&gt;test_cname&lt;/sql-column&gt;
&lt;/cmr-field&gt;
</example>

</s2>

<s2 title="sql-type" type="defun">
<p>The SQL type to be used when automatically creating a table for
the entity bean.  The sql-type is the string that will be
used in the CREATE TABLE.</p>

</s2>

</s1>

<s1 title="Formal Definition">

<def>
resin-ejb ::= enterprise-beans?, query-function*

enterprise-beans ::= entity*

entity ::= (<a href="#ejb-name">ejb-name</a>,
            <a href="#sql-table">sql-table</a>?,
            <a href="#cache-timeout">cache-timeout</a>?,
            <a href="#cache-size">cache-size</a>?,
            <a href="#data-source">data-source</a>?,
            <a href="#cmp-field">cmp-field</a>*,
            <a href="#method">method</a>*)

cmp-field ::= (<a href="#field-name">field-name</a>,
               <a href="#sql-column">sql-column</a>?,
               <a href="#abstract-sql-type">abstract-sql-type</a>?,
               <a href="#sql-type">sql-type</a>?)

sql-column ::= (<var>text(column-name)</var> |
                (<var>references</var>, <var>id</var>))

query-function ::= <a href="#signature">signature</a>

method ::= <a href="#signature">signature</a>,
           <a href="#resin-isolation">resin-isolation</a>?
           <a href="#query-loads-bean">query-loads-bean</a>?
</def>

</s1>

</body></document>