<document>
  <header>
    <product>resin-ee</product>
    <resin-2.0>$ee/ejb-tut/session-local.xtp</resin-2.0>
    <title>Local Session Counter</title>
    <description>
      <p>This example creates a local counter using a session bean.
        Session beans have a similar API to stateless session beans, but have
        internal state.  In other words, they're like servlets sessions.</p>

      <p>The EJB 2.0 spec introduced local interfaces.  Local interfaces
        let you pass arguments by reference to your beans.  This gives a small
        performance boost, but also adds a new use for EJB.  EJBs can now be
        used to better structure web applications, even applications that have
        no need for distributed objects.</p>
      
      <p>For example, almost every web application needs some sort of
        database interface.  Because EJB 2.0 provides strong support for
        container-managed-persistence, you can now use EJB for much of the
        database work without dealing with distributed objects or worrying
        about a performance.</p>
    </description>
  </header>

  <body>
    <summary/>

<s1 title="Remote Interface">

<p>The only exposed method in the local method is the <var>hit()</var>
method, used for the next count.  Notice that it does not throw
RemoteException, unlike a remote interface and that it extends
EJBLocalObject instead of EJBObject.</p>

<example title="CounterLocal.java">
package test;

import javax.ejb.*;

public interface CounterLocal extends EJBLocalObject {
  int hit();
}
</example>

</s1>

<s1 title="Local Home Interface">

<p>The Home interface's sole responsibility is to create a
new counter instance.  For session beans, only <var>create()</var> methods
belong in the home.</p>

<example title="CounterLocalHome.java">
package test;

import javax.ejb.*;

public interface CounterLocalHome extends EJBLocalHome {
  CounterLocal create() throws CreateException;
}
</example>

</s1>

<s1 title="Server Implementation">

<p>Developers will generally create a com.foo.AbstractSessionBean class
which provides default implementations for the SessionBean methods.
This example uses Resin's abstract implementation of <var>AbstractSessionBean</var>
in com.caucho.ejb that provides stubs for the SessionBean methods.</p>

<p>The session bean needs to create exactly one <var>ejbCreate</var>
method with no arguments to match the <var>create</var> in
SessionLocalHome.
It must also define the business methods.</p>

<example title="CounterBean.java">
package test;

import javax.ejb.*;

import com.caucho.ejb.*;

public class CounterBean extends AbstractSessionBean {
  int count;

  // no initialization needed
  public void ejbCreate()
  {
  }

  public int hit()
  {
    return ++count;
  }
}
</example>

</s1>

<s1 title="Servlet">

<p>In general, EJB server configuration belongs in an <var>ejb-jar.xml</var> file.
In a jar, it belongs in <var>META-INF/ejb-jar.xml</var>.</p>

<p>This name, of course, only makes sense if the EJB is put into a jar.
Jars are inconvenient during development, so Resin-EJB lets you rename
the ejb-jar.xml file as *.ejb and put it in WEB-INF.  We'll name it
<var>WEB-INF/hello.ejb</var>.</p>

<p>Local interfaces use <var>local-home</var> and <var>local</var>,
corresponding to the familiar <var>home</var> and <var>remote</var>.  It's
possible for a bean to have both local and remote interfaces.</p>

<p>The ejb-jar is a deployment descriptor for the bean.  It's part of the
EJB spec.  The ejb-jar for the stateless session example looks like the
following:</p>

<example title="counter.ejb">
&lt;ejb-jar&gt;
&lt;enterprise-beans&gt;
  &lt;session&gt;
    &lt;ejb-name&gt;counter&lt;/ejb-name&gt;
    &lt;local-home&gt;test.CounterLocalHome&lt;/local-home&gt;
    &lt;local&gt;test.CounterLocal&lt;/local&gt;
    &lt;ejb-class&gt;test.CounterBean&lt;/ejb-class&gt;
    &lt;session-type&gt;Stateful&lt;/session-type&gt;
    &lt;transaction-type&gt;Bean&lt;/transaction-type&gt;
  &lt;/session&gt;
&lt;/enterprise-beans&gt;  
&lt;/ejb-jar&gt;
</example>

<deftable>
<tr><th>Tag</th><th>Meaning
</th></tr><tr><td>ejb-jar</td><td>containing XML tag for the whole ejb-jar
</td></tr><tr><td>enterprise-beans</td><td>another container for the beans
</td></tr><tr><td>session</td><td>define a session bean
</td></tr><tr><td>ejb-name</td><td>the bean's name.  <var>hello</var> is part of the URL.
</td></tr><tr><td>local-home</td><td>the local home interface class
</td></tr><tr><td>local</td><td>the local interface class
</td></tr><tr><td>ejb-class</td><td>the implementation class
</td></tr><tr><td>session-type</td><td>Stateful is like a servlet with sessions
</td></tr><tr><td>transaction-type</td><td>Transactions.  For now, you can ignore this.
</td></tr></deftable>

</s1>

<s1 title="Configuring with Resin">

<p>Configuration for local beans is exactly the same as for remote
beans.</p>

<p>Since the ejb-jar is server-independent, it's still necessary to
instantiate the bean in a server-dependent way.  Since Resin-EJB is
JNDI resource-based configuring the bean involves configuring a resource-ref.</p>

<example title="part of resin.conf">
  &lt;ejb-server config-directory="WEB-INF"/&gt;
</example>

<p>The EJBServer automatically searches for all *.ejb files in
WEB-INF.  So it will find our hello.ejb deploy the session servlet.</p>

<p>The <var>url-prefix</var> parameter tells the EJB servlet its own
URL.  During initialization, servlets don't know their own URL, so
we need to tell it.</p>

<p>Finally, the servlet is a <var>load-on-startup</var> servlet so it will be
initialized on server startup.</p>

</s1>

<s1 title="JNDI configuration">

<p>The JNDI configuration needs to link the local-ejbs into the full JNDI
namespace.  We'll put the EJB's at java:comp/env/local-ejb.</p>

<example title="resin.conf for JNDI">
&lt;jndi-link&gt;
  &lt;jndi-name&gt;java:comp/env/local-ejb&lt;/jndi-name&gt;
  &lt;factory&gt;com.caucho.ejb.LocalContextFactory&lt;/factory&gt;
  &lt;init-param java.naming.provider.url="http://localhost:8080/ejb"/&gt;
&lt;/jndi-link&gt;
</example>

<deftable>
<tr><th>tag</th><th>meaning
</th></tr><tr><td>jndi-link</td><td>links a foreign JNDI namespace into the
application
</td></tr><tr><td>jndi-name</td><td>the "mount point" of the foreign namespace
</td></tr><tr><td>jndi-factory</td><td>the EJB's factory for looking up local
contexts.
</td></tr><tr><td>init-param</td><td>Parameters to the factory
</td></tr></deftable>

</s1>

<s1 title="Client">

<p>EJB clients follow the following steps in using a local object:</p>
<ol>
<li>Lookup the <var>home</var> stub using JNDI.
</li><li>Create an local <var>stub</var> from the home object.
</li><li>Call business methods on the <var>stub</var>.
</li></ol>

<p>Typically, an EJB client will get the home handle using JNDI.</p>

<example title="counter.jsp">
&lt;%@ page import="test.*, javax.ejb.*, javax.naming.*" %&gt;
&lt;%!
CounterLocalHome home;

// Get the home stub once and save it in home
public void _jspInit()
  throws ServletException
{
  try {
    Context cmp = (Context) new InitialContext().lookup("java:comp/env/cmp");

    home = (CounterLocalHome) env.lookup("counter");
  } catch (NamingException e) {
    e.printStackTrace();
  }
}
%&gt;&lt;%

// create the remote object
CounterLocal counter = home.create();
%&gt;
hit: &lt;%= counter.hit() %&gt;&lt;br/&gt;
hit: &lt;%= counter.hit() %&gt;
</example>
<results>
hit: 1
hit: 2
</results>

</s1>
  </body>
</document>