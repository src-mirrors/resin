<document>
  <header>
    <product>resin</product>
    <resin-2.0>$resin/ref/stylescript.xtp</resin-2.0>
    <title>XSLT-lite</title>
  </header>

  <body>
    <summary/>

<s1 title="XSLT-lite Core">

<s2 name="apply-templates" title="$apply-templates(select);" type="defun">
<p>Evaluates the children of the current node.
<code>$apply-templates</code> recursively processes the children.  If a
template has no <code>$apply-templates()</code>, then the children are
ignored.</p>

<deftable>
<tr><th>attribute</th><th>meaning
</th></tr><tr><td>select</td><td>An XPath select pattern selecting the nodes to
evaluate next. (optional)
</td></tr><tr><td>mode</td><td>only selects templates with the given <var>mode</var>
</td></tr></deftable>


<p>The following example writes the 'a' nodes followed by the 'b'
nodes and ignores everything else.</p>

<example>
$template(double) &lt;&lt;
  $apply-templates(a);
  $apply-templates(b);
&gt;&gt;
</example>

<example>
&lt;double&gt;
  &lt;b&gt;b1&lt;/b&gt;
  &lt;a&gt;a1&lt;/a&gt;
  &lt;b&gt;b2&lt;/b&gt;
  &lt;a&gt;a2&lt;/a&gt;
&lt;/double&gt;
</example>

<results>
a1
a2
b1
b2
</results>

</s2>

<s2 name="attribute" title="$attribute(name) &lt;&lt;...&gt;&gt;" type="defun">
<p>Adds an attribute to the element.  The name can be computed
using an attribute value template.</p>

<deftable>
<tr><th>Attribute</th><th>Meaning
</th></tr><tr><td>name</td><td>Name of the new attribute.
</td></tr></deftable>

<example>
$template(a) &lt;&lt;
  &lt;c&gt;
    $attribute (b{@id}) &lt;&lt;
      $value-of(c{@id});
    &gt;&gt;
  &lt;/c&gt;
&gt;&gt;
</example>
<results>
&lt;c b3='c3'/&gt;
</results>

</s2>

<s2 name="copy" title="$copy() &lt;&lt;...&gt;&gt;" type="defun">
<p>Copies the current node, but not children or attributes, to the
output.</p>

<p>To copy an element, a stylesheet must copy the attributes as well.

</p><p>The following example is the identity stylesheet. It copies input
to the output including the attributes.</p>

<example>
$template(@*|node()) &lt;&lt;
  $copy() &lt;&lt;
    $apply-templates(@*|node());
  &gt;&gt;
&gt;&gt;
</example>
</s2>

<s2 name="if" title="$if (test) &lt;&lt;... &gt;&gt;" type="defun">
<p>Executes the template if <var>test</var> is true.</p>

<example>
$template(signal) &lt;&lt;
  $if (@color="red") &lt;&lt;stop&gt;&gt;
  $else if (@color="green") &lt;&lt;go&gt;&gt;
  $else &lt;&lt;yield&gt;&gt;
&gt;&gt;
</example>
<example>
&lt;signal color="green"/&gt;
&lt;signal color="ultramaroon"/&gt;
&lt;signal color="red"/&gt;
</example>
<results>
go
yield
stop
</results>

</s2>

<s2 name="output" title="$output(...);" type="defun">
<p>Controls the output printing.</p>

<deftable>
<tr><th>Attribute</th><th>Meaning
</th></tr><tr><td>method</td><td>xml or html or text.  Select printing method
</td></tr><tr><td>version</td><td>XML version
</td></tr><tr><td>encoding</td><td>character set to print the results
</td></tr><tr><td>omit-xml-declaration</td><td>skip the XML or HTML declaration
</td></tr><tr><td>indent</td><td>pretty-print or not
</td></tr><tr><td>media-type</td><td>mime-type
</td></tr><tr><td>disable-output-escaping</td><td>'&lt;' gets printed as '&lt;', not '&amp;lt;'
</td></tr></deftable>

</s2>

<s2 name="template" title="$template(match) &lt;&lt; ... &gt;&gt;" type="defun">
<p>Establishes a pattern and replacement text.
<code>$template</code> registers its pattern with the XSL processing
engine.  When a node matches the pattern, XSL will process the
contents of the template.</p>

<p>Pure XSL processes the contents slightly differently than XTP.  XSL
expects all tags to be valid XML.  XTP is more forgiving.  If the tag is not
one of those defined by XSL, it will treat the tag as raw text.</p>

<deftable>
<tr><th>attribute</th><th>meaning
</th></tr><tr><td>match</td><td>the XPath match pattern (required)
</td></tr><tr><td>mode</td><td>string grouping templates into a special mode
</td></tr><tr><td>name</td><td>Name for later use by call-template
</td></tr><tr><td>priority</td><td>conflict-resolving priority, an integer
</td></tr></deftable>

<p>In the following example, the template matches any 'box' tag.  The
contents of the box are placed in a centered table 80% of the current
width.</p>

<example>
$template(box) &lt;&lt;
<var>  &lt;center&gt;
  &lt;table width='80%'&gt;
  &lt;tr&gt;&lt;td&gt;</var>
    $apply-templates();
<var>  &lt;/td&gt;&lt;/tr&gt;
  &lt;/table&gt;
  &lt;/center&gt;</var>
&gt;&gt;
</example>

<example>
&lt;p&gt;Here's a boxed quote,&lt;/p&gt;

&lt;box&gt;
To be or not to be...
&lt;/box&gt;
</example>

<results>
&lt;p&gt;Here's a boxed quote,&lt;/p&gt;

&lt;center&gt;
&lt;table width='80%'&gt;
&lt;tr&gt;&lt;td&gt;
  To be or not to be...
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;/center&gt;
</results>

</s2>

<s2 name="value-of" title="$value-of(select);" type="defun">
<p>Writes a calculated value output.</p>  

<p><code>value-of</code> is particularly useful for extracting attribute
values.  The following example creates a JSP tag which adds two
numbers.</p>

<example>
$template(ct:sum) &lt;&lt;
<var>&lt;jsp:expression&gt;</var>
$value-of(@a);<var> + </var>$value-of(@b);
<var>&lt;/jsp:expression&gt;</var>
&gt;&gt;
</example>
</s2>

</s1>

<s1 title="XSLT-lite Elements">

<s2 name="apply-imports" title="$apply-imports();" type="defun">
<p>Like Java's <code>super</code>, calls the overridden template.</p>
</s2>

<s2 name="attribute-set" title="$attribute-set(name) &lt;&lt;...&gt;&gt;" type="defun">
<p>Defines a named attribute set.  The attributes in the set
are defined by xsl:attribute elements.</p>

<deftable>
<tr><th>Attribute</th><th>Meaning
</th></tr><tr><td>name</td><td>Name of the attribute set.
</td></tr></deftable>

<example>
$attribute-set(font) &lt;&lt;
  $attribute(font-size) &lt;&lt;12pt&gt;&gt;
  $attribute(font-weight) &lt;&lt;bold&gt;&gt;
&gt;&gt;

$template(a) &lt;&lt;
  &lt;c xsl:use-attribute-sets='font'/&gt;
&gt;&gt;
</example>
<results>
&lt;c font-size='12pt' font-weight='bold'/&gt;
</results>

</s2>

<s2 name="call-template" title="$call-template(name) &lt;&lt;...&gt;&gt;" type="defun">
<p>Calls a named template with the current node.
<code>$call-template</code> lets stylesheets reuse common code, like
functions.  It works like <code>$apply-templates(.);</code>
except that it calls based on a template name.</p>

<deftable>
<tr><th>Attribute</th><th>Meaning
</th></tr><tr><td>name</td><td>template name to call
</td></tr><tr><td>mode</td><td>template mode
</td></tr></deftable>
</s2>

<s2 name="choose" title="$choose(test) &lt;&lt;...&gt;&gt;" type="defun">
<p>Implements a select block.  The <code>$when</code>
statements are tested in order.  The first matching one is executed.
If none match, the <code>$otherwise</code> block is executed.</p>

<deftable>
<tr><th>Attribute</th><th>Meaning
</th></tr><tr><td>test</td><td>XPath expression evaluating to a boolean.
</td></tr></deftable>

<example>
$template(a) &lt;&lt;
  $choose() &lt;&lt;
    $when(@color="red") &lt;&lt;stop&gt;&gt;
    $when(@color="green") &lt;&lt;go&gt;&gt;
    $otherwise() &lt;&lt;yield&gt;&gt;
  &gt;&gt;
&gt;&gt;
</example>

</s2>

<s2 name="comment" title="$comment() &lt;&lt;...&gt;&gt;" type="defun">
<p>Creates a new comment.  The contents of the $comment() element
become the contents of the comment.</p>

<example>
$template(a) &lt;&lt;
  $comment() &lt;&lt; Text for the comment. &gt;&gt;
&gt;&gt;
</example>
<results>
&lt;!-- Text for the comment. --&gt;
</results>

</s2>

<s2 name="copy-of" title="$copy-of(select);" type="defun">
<p>Copies a sub-tree into the output. <code>$copy-of</code> resembles
<code>$value-of</code>.  <code>value-of</code> always converts the value to a
string.  <code>copy-of</code> will copy subtrees. </p>

<deftable>
<tr><th>attribute</th><th>meaning
</th></tr><tr><td>select</td><td>An XPath expression to be copied.
</td></tr></deftable>
</s2>

<s2 name="element" title="$element(name) &lt;&lt;...&gt;&gt;" type="defun">
<p>Creates a new element.  The name can be computed using
an attribute value template.</p>

<deftable>
<tr><th>Attribute</th><th>Meaning
</th></tr><tr><td>name</td><td>Name of the new element.
</td></tr></deftable>

<example>
$template(a) &lt;&lt;
  $element(b{@id}) &lt;&lt;
    <var>&lt;c/&gt;</var>
  &gt;&gt;
&gt;&gt;
</example>
<example>
&lt;a id="3"/&gt;
</example>
<results>
&lt;b3&gt;&lt;c/&gt;&lt;/b3&gt;
</results>

</s2>

<s2 name="for-each" title="$for-each(select) &lt;&lt; ... &gt;&gt;" type="defun">
<p>Loops over child select patterns.  <code>$for-each()</code>
gives stylesheets complete control over the actions for child nodes.
</p>

<p>Usually, stylesheets will want to use the full pattern matching
capability given by XSL.  Sometimes the specific structure is known,
like sections in a chapter.  When generating a table of contents, it
may be easier to scan over the sections.</p>

<example>
$template(contents) &lt;&lt;
<var>  &lt;ol&gt;</var>
  $for-each(section) &lt;&lt;
    <var>&lt;li&gt;</var>$value-of(@title);<var>&lt;/li&gt;</var>
  &gt;&gt;
<var>  &lt;/ol&gt;</var>
&gt;&gt;
</example>

</s2>

<s2 name="import" title="$import(href);" type="defun">
<p>Imports a stylesheet.  <code>$import</code> lets stylesheets
borrow from each other.</p>

<deftable>
<tr><th>Attribute</th><th>Meaning
</th></tr><tr><td>href</td><td>Path to the imported stylesheet
</td></tr></deftable>

</s2>

<s2 name="param" title="$param(name);" type="defun">
<p>Declares an XSL parameter.  <code>$param</code>'s
<code>select</code> parameter as a default.  If the variable has been
assigned, it uses the old value.</p>

<deftable>
<tr><th>Attribute</th><th>Meaning
</th></tr><tr><td>name</td><td>variable name
</td></tr><tr><td>select</td><td>variable value
</td></tr></deftable>

<example>
$template(name=&gt;fun) &lt;&lt;
  $param(foo, select=&gt;15);
  $value-of($foo);
&gt;&gt;

$template(a) &lt;&lt;
  $call-template(fun) &lt;&lt;
    $with-param(foo, select=&gt;1+2);
  &gt;&gt;
&gt;&gt;

</example>
<results>
3
</results>

</s2>

<s2 name="pi" title="$processing-instruction(name) &lt;&lt;...&gt;&gt;" type="defun">
<p>Creates a new processing instruction.</p>

<deftable>
<tr><th>Attribute</th><th>Meaning
</th></tr><tr><td>name</td><td>Processing instruction name.
</td></tr></deftable>

<example>
$template(a) &lt;&lt;
  $processing-instruction(foo) &lt;&lt; Text for the PI. &gt;&gt;
&gt;&gt;
</example>
<results>
&lt;?foo Text for the PI?&gt;
</results>

</s2>

<s2 name="sort" title="$sort(...) &lt;&lt;...&gt;&gt;" type="defun">
<p>Sorts nodes in $apply-templates or
$for-each.</p>

<deftable>
<tr><th>Attribute</th><th>Meaning
</th></tr><tr><td>select</td><td>value to sort on (default = '.')
</td></tr><tr><td>order</td><td>ascending or descending  (default = ascending)
</td></tr><tr><td>data-type</td><td>text or number (default = text)
</td></tr></deftable>

<note>case-order is not implemented</note>
</s2>

<s2 name="text" title="$text() &lt;&lt;...&gt;&gt;" type="defun">
<p>Writes the contents to the output.  <code>$text</code> is
useful when you need to force spacing or special text.  Usually,
XSLT-lite will produce the text you expect.  <code>$text</code> is there
for the strange cases when you need full control.</p>
</s2>

<s2 name="variable" title="$variable(name);" type="defun">
<p>Assignes an XSL variable.  Variables can be retrieved using
the XPath variable syntax.</p>

<deftable>
<tr><th>Attribute</th><th>Meaning
</th></tr><tr><td>name</td><td>variable name
</td></tr><tr><td>select</td><td>variable value
</td></tr></deftable>

<example>
$variable(foo, select=&gt;1+1);

$template(a) &lt;&lt;
  $value-of($foo);
&gt;&gt;
</example>
<results>
2
</results>

</s2>
</s1>

<s1 name="xsl" title="Resin extensions">
<s2 name="expression" title="$expr(expr);" version="Resin 1.2" type="defun">
<p>Prints the value of the Java expression, <var>expr</var>.
Stylesheets can use any Java expression.  The following
variables are pre-defined in stylesheets.</p>

<deftable>
<tr><th>Variable</th><th>Meaning
</th></tr><tr><td>node</td><td>The current org.w3c.dom.Node.
</td></tr><tr><td>out</td><td>The com.caucho.xsl.XslWriter.
</td></tr></deftable>

<p>In addition, the <var>out</var> variable gives access to the servlet
PageContext with the <var>page</var> property.</p>

<example>
$template(welcome-user) &lt;&lt;
  $text() &lt;&lt;Welcome back, &gt;&gt;
  $scriptlet() &lt;&lt;
    String user = "Harry";
  &gt;&gt;
  $expr(user);
&gt;&gt;
</example>
</s2>

<s2 name="scriptlet" title="$scriptlet() &lt;&lt; statement_list &gt;&gt;" version="Resin 1.2" type="defun">
<p>Executes the <var>statement_list</var> scriptlet.  The
JavaScript code can be any statement list.  The same implicit
variables are allowed in scriptlets as in expressions.</p>

<p>The following example creates a number of stars:</p>

<example>
$template(ct:stars) &lt;&lt;
  $scriptlet() &lt;&lt;
    int count = Integer.parseInt(node.getAttribute("count"));
    for (int i = 0; i &lt; count; i++)
      out.print('*');
  &gt;&gt;
&gt;&gt;
</example>

<example>
1 = &lt;ct:stars count='1'/&gt;
9 = &lt;ct:stars count='9'/&gt;
</example>
<results>
1 = *
9 = *********
</results>

</s2>

<s2 name="declaration" title="$declaration" type="defun">
<p>Adds declaration code, i.e. code outside of any function.</p>

<example>
$declaration &lt;&lt;
double dist(double x1, double y1, double x2, double y2)
{
  return Math.sqrt((x1 - x2) * (x1 - x2) +
                   (y1 - y2) * (y1 - y2));
}
&gt;&gt;

</example>

</s2>

<s2 name="page" title="$directive.page(attributes);" type="defun">
<p>Sets page directives.</p>
<deftable>
<tr><th>name</th><th>meaning
</th></tr><tr><td>language</td><td>script language, default Java
</td></tr><tr><td>session</td><td>use sessions, default false
</td></tr><tr><td>errorPage</td><td>page to display for errors
</td></tr><tr><td>errorPage</td><td>page to display for errors
</td></tr><tr><td>import</td><td>imports Java packages 
</td></tr><tr><td>contentType</td><td>content-type of the generated page
</td></tr></deftable>

</s2>
<!--
<defun name=cache title='$directive.cache(attributes);'>

<p>Caches the generated JSP file by default.</p>

<p>Caching for XSL is more complicated than for JSP because only some
templates may be used in a page.  Caching is based on the generated
page, not simply on the stylesheet.

<p>A page that just uses static
templates is automatically cached.  Pages that use scripts just for
simple calculation can also be cached.  But pages that use scripts
based on the request cannot be cached.</p>

<deftable>
<tr><th>name<th>meaning
<tr><td>file<td>the JSP file depends on <var/file/>.
<tr><td>no-cache<td>do not cache the generated JSP.
</deftable>

</defun>
-->

</s1>

<s1 title="Abbreviations">

<s2 name="value-of" title="$(expr)" index="value-of" type="defun">
<p>$value-of shortcut prints the value of the XPath expression.</p>

<p>The value-of syntax is equivalent to:</p>
<def>
$value-of(<var>expr</var>);
</def>

</s2>

<s2 name="expression" title="&lt;#= expression #&gt;" index="expression" type="defun">
<p>$expression shortcut prints the value of <var>expression</var> using
the page's scripting language.</p>

<p>The expression syntax is equivalent to:</p>
<def>
$expr(<var>expression</var>);
</def>

</s2>

<s2 name="scriptlet" title="&lt;# statement-list #&gt;" type="defun">
<p>$scriptlet shortcut executes the statements using the page's
scripting language.</p>

<p>The <var>scriptlet</var> is any statement list in the language,
e.g. Java.

</p><p>The scriptlet syntax is equivalent to </p>
<def>
$scriptlet() &lt;&lt;
<var>scriptlet</var>
&gt;&gt;
</def>

</s2>

<s2 name="declaration" title="&lt;#! declaration #&gt;" index="declaration" type="defun">
<p>$declaration shortcut defines functions and variables.</p>

<p>The declaration syntax is equivalent to:</p>
<def>
$declaration() &lt;&lt;
<var>declaration</var>
&gt;&gt;
</def>

<example>
&lt;#!
function dist(x1, y1, x2, y2)
{
  return Math.sqrt((x1 - x2) * (x1 - x2) +
                   (y1 - y2) * (y1 - y2));
}
#&gt;

ct:dist &lt;&lt;
($(@x1),$(@y1)) to ($(@x2),$(@y2)) = &amp;lt#=
dist(node.attribute.x1, node.attribute.y1,
     node.attribute.x2, node.attribute.y2)
#&gt;

&gt;&gt;
</example>
<example>
&lt;ct:dist x1='0' y1='0' x2='5' y2='12'/&gt;
</example>
<results>
(0,0) to (5,12) = 13
</results>

</s2>
</s1>
  </body>
</document>