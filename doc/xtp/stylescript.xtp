<document>
  <header>
    <product>resin</product>
    <resin-2.0>$resin/ref/xslt-lite.xtp</resin-2.0>
    <title>StyleScript</title>

    <keywords>
      <keyword>xslt</keyword>
    </keywords>

    <description>
      <p>'StyleScript' adds some syntactic sugar to XSLT to make stylesheets more
        readable.  It lets authors cut down on XSL's verbosity, without losing
        any of the power.  Stylesheets are also freed from the constraints of
        XML, like entity references ('&amp;amp;').</p>
      
      <p>StyleScript can treat unknown elements as text, like JSP.  Setting
        the xsl:stylesheet attribute parsed-content to false will treat
        elements as text.  By default, StyleScript uses XSLT behaviour.
        StyleScript templates can create the HTML '&lt;br&gt;', even though it's
        illegal XML.  It doesn't expand entities in templates. '&amp;lt;'
        produces 4 characters.  </p>

      <p>StyleScript doesn't expand entities in templates. '&amp;lt;'
        produces 4 characters.  To escape in StyleScript, use the backslash as
        in JSP.</p>
    </description>
      
  </header>

  <body>
    <summary/>

<s1 name="directives" title="directives">

<s2 name="page" title="&lt;#@ page attributes #&gt;" type="defun">
<sum>Sets page directives</sum>
<deftable>
<tr><th>name</th><th>meaning
</th></tr><tr><td>language</td><td>script language, default Java
</td></tr><tr><td>session</td><td>use sessions, default false
</td></tr><tr><td>errorPage</td><td>page to display for errors
</td></tr><tr><td>errorPage</td><td>page to display for errors
</td></tr><tr><td>import</td><td>imports Java packages 
</td></tr><tr><td>contentType</td><td>content-type of the generated page
</td></tr></deftable>

Equivalent to:
<def>
&lt;xtp:directive.page <var>attributes</var>/&gt;
</def>

</s2>

<s2 name="cache" title="&lt;#@ cache attributes #&gt;" type="defun">

<sum>Caches the generated JSP file by default.</sum>

<p>Caching for XSL is more complicated than for JSP because only some
templates may be used in a page.  Caching is based on the generated
page, not simply on the stylesheet.

</p><p/>A page that just uses static
templates is automatically cached.  Pages that use scripts just for
simple calculation can also be cached.  But pages that use scripts
based on the request cannot be cached.

<deftable>
<tr><th>name</th><th>meaning
</th></tr><tr><td>file</td><td>the JSP file depends on <var>file</var>.
</td></tr><tr><td>no-cache</td><td>do not cache the generated JSP.
</td></tr></deftable>

Equivalent to:
<def>
&lt;xtp:directive.cache <var>attributes</var>/&gt;
</def>

The following example caches by default, but disables caching when
using the counter:
<example>
&lt;#@ cache #&gt;

ct:counter &lt;&lt;
&lt;#@ cache no-cache #&gt;
&lt;#= out.page.application.attribute.counter++ #&gt;
&gt;&gt;
</example>

Or programmatically:
<example>
&lt;#@ cache #&gt;

ct:counter &lt;#
out.setNotCacheable();
out.write(out.page.application.attribute.counter++)
#&gt;
</example>

</s2>

</s1>

<s1 name="templates" title="templates">

<s2 name="short-content" title="pattern &lt;&lt; xsl-content &gt;&gt;" index="template" type="defun">
<sum>Short form of xsl:template.</sum>  <var>xsl-content</var> is any
normal xsl content including text and the StyleScript actions.

<p/>The short template syntax is equivalent to:
<def>
&lt;xsl:template match='<var>pattern</var>'&gt;
<var>xsl-content</var>
&lt;/xsl:template&gt;
</def>

</s2>

<s2 name="temp-expr" title="pattern &lt;#= expression #&gt;" index="template, expression" type="defun">
<sum>Templates which just print an expression.</sum>  <var>expression</var> is
a Java or JavaScript expression.

<p/>The syntax is equivalent to:
<def>
&lt;xsl:template match='<var>pattern</var>'&gt;
&lt;xtp:expression&gt;
  <var>expression</var>
&lt;/xtp:expression&gt;
&lt;/xsl:template&gt;
</def>

</s2>

<s2 name="temp-script" title="pattern &lt;# scriptlet #&gt;" index="template, expression" type="defun">
<sum>Templates which are generated by JavaScript or Java.</sum>

<p/>The syntax is equivalent to:
<def>
&lt;xsl:template match='<var>pattern</var>'&gt;
&lt;xtp:scriptlet&gt;
  <var>scriptlet</var>
&lt;/xtp:scriptlet&gt;
&lt;/xsl:template&gt;
</def>

</s2>

</s1>

<s1 name="actions" title="actions">

<s2 name="value-of" title="$(expression)" index="value-of" type="defun">
<sum>Prints the value of the XSL <var>expression</var>.</sum>  This syntax
is a short cut for the xsl:value-of tag.

<p/>The value-of syntax is equivalent to:
<def>
&lt;xsl:value-of select="<var>expression</var>"/&gt;
</def>

</s2>

<s2 name="expression" title="&lt;#= expression #&gt;" index="expression" type="defun">
<sum>Prints the value of <var>expression</var> using the page's language.</sum>

<p/>The expression syntax is equivalent to:
<def>
&lt;xtp:expression&gt;
<var>expression</var>
&lt;/xtp:expression&gt;
</def>

For example, to print the request URL using JavaScript:
<example>
<example>
ct:url &lt;&lt;
url: &lt;#= out.page.request.requestURL #&gt;
&gt;&gt;
</example>
<results>
url: /test/url.xtp
</results>
</example>

</s2>

<s2 name="scriptlet" title="&lt;# scriptlet #&gt;" index="scriptlets" type="defun">
<sum>Executes the statements in <var>scriptlet</var> using the page's
<a href="jsp|directives#language">language</a>.</sum>

<p>The <var>scriptlet</var> is any statement list in the language,
e.g. Java.

</p><p/>The scriptlet syntax is equivalent to 
<def>
&lt;xtp:scriptlet&gt;
<var>scriptlet</var>
&lt;/xtp:scriptlet&gt;
</def>

For example, to print all headers:
<example>
ct:headers &lt;&lt;
Headers: &lt;# 
  for (var header in out.page.request.header) {
    out.println(header, ":", out.page.request.header[header]);
  }
#&gt;
&gt;&gt;
</example>

</s2>

<s2 name="declaration" title="&lt;#! declaration #&gt;" index="declaration" type="defun">
<sum>Adds declaration code, i.e. code outside of any function.</sum>

<p/>The declaration syntax is equivalent to:
<def>
&lt;xtp:declaration&gt;
<var>declaration</var>
&lt;/xtp:declaration&gt;
</def>

<example>
<example>
&lt;#!
function dist(x1, y1, x2, y2)
{
  return Math.sqrt((x1 - x2) * (x1 - x2) +
                   (y1 - y2) * (y1 - y2));
}
#&gt;

ct:dist &lt;&lt;
($(@x1),$(@y1)) to ($(@x2),$(@y2)) = &amp;lt#=
dist(node.attribute.x1, node.attribute.y1,
     node.attribute.x2, node.attribute.y2)
#&gt;

&gt;&gt;
</example>
<example>
&lt;ct:dist x1='0' y1='0' x2='5' y2='12'/&gt;
</example>
<results>
(0,0) to (5,12) = 13
</results>
</example>

</s2>
</s1>
  </body>
</document>